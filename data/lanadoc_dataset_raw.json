[
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\n\nconst express = require('express')\n\nconst router = express.Router()\n\nconst quoteController = require('../controllers/quote_controller')\n\nrouter.get(\"/v1/quotes\", quoteController.getAllQuotes);\n\nrouter.get(\"/v1/quote\", quoteController.getSingleQuote)\n\nrouter.get(\"/v1/quote/:count\", quoteController.getNumberOfQuotes)\n\nrouter.get(\"/v1/quote/filter/known\",quoteController.getSingleKnownAuthor)\n\nrouter.get(\"/v1/quote/filter/known/:count\",quoteController.getMultipleKnownAuthor)\n\nrouter.get(\"/v1/quote/filter/:keyword\", quoteController.getSingleMatch)\n\nrouter.get(\"/v1/quote/filter/all/:keyword\", quoteController.getAllMatch)\n\nmodule.exports = router\n\nBelow are the implementations:\n\n\nconst quotes = require(\"../quotes\");\n\n// function to get random quote\nfunction getRandomQuotes() {\n  const quote = quotes[Math.floor(Math.random() * quotes.length)];\n  return quote;\n}\n\nfunction getKnownRandomQuote() {\n  // Single Random Known Author\n  const mquotes = quotes.filter((q) => q.author !== \"Unknown Author\");\n\n  const mKnownRandom = mquotes[Math.floor(Math.random() * mquotes.length)];\n\n  return mKnownRandom;\n}\n\nfunction getKnownRandomQuotes(number) {\n  // Multiple Random Known Author\n\n  let quotesNumberGen = [];\n\n  for (let i = 0; i < number; i++) {\n    quotesNumberGen.push(getKnownRandomQuote());\n  }\n  return quotesNumberGen;\n}\n\nfunction genNumberOfQuotes(genNumber) {\n  // Array to store the randomly generated quotes\n  let quotesNumberGen = [];\n  // Loop to get all the number of quotes specified by user in his request\n  for (let i = 0; i < genNumber; i++) {\n    quotesNumberGen.push(getRandomQuotes());\n  }\n  return quotesNumberGen;\n}\n\nconst { findAllMatches, findFirstMatch } = require(\"../quotes/QuotesUtils\");\n\nexports.getAllQuotes = (req, res) => {\n  res.send(quotes);\n};\n\nexports.getSingleQuote = (req, res) => {\n  res.send(getRandomQuotes());\n};\n\n// get a certain number of quotes each time they hit the endpoint\nexports.getNumberOfQuotes = (req, res) => {\n  if (isNaN(parseInt(req.params.count)))\n    res.send({\n      error: {\n        message: \"Count is not a number.\",\n        code: 400,\n      },\n    });\n  console.log(\"User requested for \" + req.params.count + \" number of quote(s)\");\n  let quotesList = genNumberOfQuotes(req.params.count);\n  res.send(quotesList);\n};\n\nexports.getSingleKnownAuthor = (req, res) => {\n  let ranQuote = getKnownRandomQuote();\n  res.send(ranQuote);\n};\n\nexports.getMultipleKnownAuthor = (req, res) => {\n  res.send(getKnownRandomQuotes(req.params.count));\n};\n\nexports.getSingleMatch = (req, res) => {\n  console.log(`User searched for first match of ${req.params.keyword}`);\n  let mQuote = findFirstMatch(req.params.keyword);\n  let emptyQuote = { quote: \"\", author: \"\" };\n  res.send(mQuote ? mQuote : emptyQuote);\n};\n\nexports.getAllMatch = (req, res) => {\n  console.log(`User searched for all matches of ${req.params.keyword}`);\n  let quotesList = findAllMatches(req.params.keyword);\n  res.send(quotesList ? quotesList : []);\n};",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"Geek Quote API\",\n        \"version\": \"1.0.0\",\n        \"description\": \"The Quote API provides a rich collection of inspirational quotes. It allows you to retrieve random quotes, filter quotes by keywords, and discover quotes from well-known authors.\",\n        \"termsOfService\": \"https://example.com/terms\",\n        \"contact\": {\n            \"name\": \"example\",\n            \"email\": \"contact@example.com\",\n            \"url\": \"https://example.com\"\n        },\n        \"license\": {\n            \"name\": \"Apache 2.0\",\n            \"url\": \"https://www.apache.org/licenses/LICENSE-2.0\"\n        }\n    },\n    \"servers\": [\n        {\n            \"url\": \"https://geek-quote-api.vercel.app\",\n            \"description\": \"Production server\"\n        },\n        {\n            \"url\": \"https://localhost:3000\",\n            \"description\": \"Development server\"\n        }\n    ],\n    \"paths\": {\n        \"/v1/quotes\": {\n            \"get\": {\n                \"summary\": \"Get all quotes\",\n                \"description\": \"Retrieve all quotes available in the API's database. This endpoint provides access to the entire collection of quotes, allowing for a complete list to be retrieved in a single call. It's useful for applications that need to display or process all quotes at once.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"A complete list of quotes was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Quote\"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the quotes.\"\n                    }\n                }\n            }\n        },\n        \"/v1/quote\": {\n            \"get\": {\n                \"summary\": \"Get random quote\",\n                \"description\": \"Retrieve a single random quote from the collection. This endpoint selects one quote at random, providing a fresh and unexpected quote each time it is called. Itâ€™s ideal for features that need to show a daily or periodically changing quote.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"A random quote was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Quote\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the quote.\"\n                    }\n                }\n            }\n        },\n        \"/v1/quote/{count}\": {\n            \"get\": {\n                \"summary\": \"Get multiple quotes\",\n                \"description\": \"Retrieve a specified number of random quotes. The number of quotes returned is determined by the `count` parameter provided in the request. This is useful for applications that need to display multiple quotes at once or perform bulk operations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"count\",\n                        \"in\": \"path\",\n                        \"description\": \"The number of random quotes to retrieve. The count must be a positive integer to ensure valid input and proper functionality.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\",\n                            \"example\": 5\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The specified number of quotes was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Quote\"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"400\": {\n                        \"description\": \"The request is invalid because the count is not a positive integer. Ensure the `count` parameter is properly formatted.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                },\n                                \"examples\": {\n                                    \"invalidCount\": {\n                                        \"summary\": \"Invalid count\",\n                                        \"value\": {\n                                            \"error\": {\n                                                \"message\": \"Count must be a positive integer.\",\n                                                \"code\": 400\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the quotes.\"\n                    }\n                }\n            }\n        },\n        \"/v1/quote/filter/known\": {\n            \"get\": {\n                \"summary\": \"Get known author quote\",\n                \"description\": \"Retrieve a random quote from a known author. This endpoint selects one quote at random from a pool of quotes attributed to famous and recognizable authors, making it ideal for applications that want to provide reputable or authoritative quotes.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"A quote from a known author was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Quote\"\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"No quotes from known authors were found in the database. Ensure that there are quotes from known authors available before making this request.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                },\n                                \"examples\": {\n                                    \"noKnownAuthors\": {\n                                        \"summary\": \"No known authors\",\n                                        \"value\": {\n                                            \"error\": {\n                                                \"message\": \"No quotes from known authors found.\",\n                                                \"code\": 404\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the quote.\"\n                    }\n                }\n            }\n        },\n        \"/v1/quote/filter/known/{count}\": {\n            \"get\": {\n                \"summary\": \"Get multiple known author quotes\",\n                \"description\": \"Retrieve a specified number of quotes from known authors. This endpoint returns a set number of quotes from well-known authors, allowing for bulk retrieval of reputable quotes.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"count\",\n                        \"in\": \"path\",\n                        \"description\": \"The number of quotes to retrieve. The count must be a positive integer to ensure valid input and proper functionality.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\",\n                            \"example\": 3\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The specified number of quotes from known authors was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Quote\"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"400\": {\n                        \"description\": \"The request is invalid because the count is not a positive integer. Ensure the `count` parameter is properly formatted.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                },\n                                \"examples\": {\n                                    \"invalidCount\": {\n                                        \"summary\": \"Invalid count\",\n                                        \"value\": {\n                                            \"error\": {\n                                                \"message\": \"Count must be a positive integer.\",\n                                                \"code\": 400\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"No quotes from known authors were found in the database. Ensure that there are quotes from known authors available before making this request.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                },\n                                \"examples\": {\n                                    \"noKnownAuthors\": {\n                                        \"summary\": \"No known authors\",\n                                        \"value\": {\n                                            \"error\": {\n                                                \"message\": \"No quotes from known authors found.\",\n                                                \"code\": 404\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the quotes.\"\n                    }\n                }\n            }\n        },\n        \"/v1/quote/filter/{keyword}\": {\n            \"get\": {\n                \"summary\": \"Get quote by keyword\",\n                \"description\": \"Retrieve the first quote that matches the specified keyword. This endpoint searches the collection for quotes that contain the keyword and returns the first match found.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"keyword\",\n                        \"in\": \"path\",\n                        \"description\": \"The keyword to search for in quotes. The keyword must be a valid string and relevant to the content of the quotes.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\",\n                            \"example\": \"inspiration\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The first quote matching the keyword was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Quote\"\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"No quotes matching the keyword were found. Verify that the keyword is appropriate and try again.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                },\n                                \"examples\": {\n                                    \"noMatch\": {\n                                        \"summary\": \"No match\",\n                                        \"value\": {\n                                            \"error\": {\n                                                \"message\": \"No quotes found matching the keyword.\",\n                                                \"code\": 404\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the quote.\"\n                    }\n                }\n            }\n        },\n        \"/v1/quote/filter/all/{keyword}\": {\n            \"get\": {\n                \"summary\": \"Get all quotes by keyword\",\n                \"description\": \"Retrieve all quotes that match the specified keyword. This endpoint searches the collection for quotes that contain the keyword and returns all matches found.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"keyword\",\n                        \"in\": \"path\",\n                        \"description\": \"The keyword to search for in quotes. The keyword must be a valid string and relevant to the content of the quotes.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\",\n                            \"example\": \"motivation\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"All quotes matching the keyword were successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Quote\"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"No quotes matching the keyword were found. Verify that the keyword is appropriate and try again.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                },\n                                \"examples\": {\n                                    \"noMatch\": {\n                                        \"summary\": \"No match\",\n                                        \"value\": {\n                                            \"error\": {\n                                                \"message\": \"No quotes found matching the keyword.\",\n                                                \"code\": 404\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the quotes.\"\n                    }\n                }\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"Quote\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"quote\": {\n                        \"type\": \"string\",\n                        \"description\": \"The text of the quote.\",\n                        \"example\": \"To be, or not to be, that is the question.\"\n                    },\n                    \"author\": {\n                        \"type\": \"string\",\n                        \"description\": \"The author of the quote.\",\n                        \"example\": \"William Shakespeare\"\n                    }\n                }\n            },\n            \"Error\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"error\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"message\": {\n                                \"type\": \"string\",\n                                \"description\": \"The error message.\",\n                                \"example\": \"Count must be a positive integer.\"\n                            },\n                            \"code\": {\n                                \"type\": \"integer\",\n                                \"description\": \"The error code.\",\n                                \"example\": 400\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nimport { Router } from 'express';\nimport messagesRouter from './messages.routes';\nimport usersRouter from './users.routes';\nimport sessionsRouter from './sessions.routes';\nimport tokensRouter from './tokens.routes';\nimport contactsRouter from './contacts.routes';\nimport screenshotRouter from './screenshot.routes';\n\nimport ensureAuthenticated from '../middlewares/ensureAuthenticated';\nimport ensureAdminOnly from '../middlewares/ensureAdminOnly';\n\nconst routes = Router();\n\nroutes.use('/sessions', sessionsRouter);\n\nroutes.use(ensureAuthenticated);\n\nroutes.use('/messages', messagesRouter);\nroutes.use('/users', ensureAdminOnly, usersRouter);\nroutes.use('/tokens', ensureAdminOnly, tokensRouter);\nroutes.use('/contacts', ensureAdminOnly, contactsRouter);\nroutes.use('/screenshot', ensureAdminOnly, screenshotRouter);\n\nexport default routes;\n\n\nimport { Router } from 'express';\nimport ContactsController from '../controllers/ContactsController';\n\nconst contactsRouter = Router();\nconst contactController = new ContactsController();\n\ncontactsRouter.get('/:phoneNumber', contactController.index);\n\nexport default contactsRouter;\n\n\nimport { Router } from 'express';\nimport MessagesController from '../controllers/MessagesController';\n\nconst messagesRouter = Router();\nconst messageController = new MessagesController();\n\nmessagesRouter.get('/', messageController.index);\n\nmessagesRouter.get('/:id', messageController.show);\n\nmessagesRouter.delete('/:id', messageController.delete);\n\nmessagesRouter.post('/', messageController.create);\n\nexport default messagesRouter;\n\n\nimport { Router } from 'express';\nimport ScreenshotController from '../controllers/ScreenshotController';\n\nconst screenshotRouter = Router();\nconst screenshotController = new ScreenshotController();\n\nscreenshotRouter.get('/', screenshotController.index);\n\nexport default screenshotRouter;\n\n\nimport { Router } from 'express';\n\nimport SessionsController from '../controllers/SessionsController';\n\nconst sessionsRouter = Router();\nconst sessionsController = new SessionsController();\n\nsessionsRouter.post('/', sessionsController.create);\n\nexport default sessionsRouter;\n\n\nimport { Router } from 'express';\nimport TokensController from '../controllers/TokensController';\n\nconst tokensRouter = Router();\nconst tokenController = new TokensController();\n\ntokensRouter.post('/', tokenController.create);\n\ntokensRouter.get('/', tokenController.index);\n\ntokensRouter.delete('/:phone', tokenController.delete);\n\nexport default tokensRouter;\n\n\nimport { Router } from 'express';\nimport UsersController from '../controllers/UsersController';\n\nconst usersRouter = Router();\nconst userController = new UsersController();\n\nusersRouter.post('/', userController.create);\n\nusersRouter.delete('/', userController.delete);\n\nexport default usersRouter;\n\nBelow are the implementations: \n\n import { Request, Response } from 'express';\nimport Whatsapp from '../whatsapp/client';\n\nexport default class ContactsController {\n  private whatsapp: Whatsapp;\n\n  public async index(request: Request, response: Response): Promise<Response> {\n    const { phoneNumber } = request.params;\n    const onlyGroup = request.query.onlyGroup === 'true';\n\n    if (!this.whatsapp) {\n      this.whatsapp = new Whatsapp();\n    }\n\n    const contacts = (await this.whatsapp.getContacts(phoneNumber))\n      .filter(contact => (onlyGroup ? contact.isGroup : true))\n      .map(contact => ({ id: contact.id.user, name: contact.name }));\n\n    return response.json({ contacts });\n  }\n}\n\n\nimport { parseISO } from 'date-fns';\nimport { Request, Response } from 'express';\nimport { getCustomRepository } from 'typeorm';\nimport AppError from '../errors/AppError';\nimport MessagesRepository from '../repositories/MessagesRepository';\nimport CreateMessageService from '../services/CreateMessageService';\n\nconst RES_PER_PAGE = 10;\n\ninterface IQueryParams {\n  page: number;\n  q: string;\n}\n\nexport default class MessagesController {\n  public async create(request: Request, response: Response): Promise<Response> {\n    const { from, to, message, image, schedule_date } = request.body;\n\n    const parsedScheduleDate = schedule_date\n      ? parseISO(schedule_date)\n      : undefined;\n\n    const createMessage = new CreateMessageService();\n\n    const newMessage = await createMessage.execute({\n      from,\n      to,\n      message,\n      image,\n      schedule_date: parsedScheduleDate,\n    });\n\n    return response.json(newMessage);\n  }\n\n  public async index(request: Request, response: Response): Promise<Response> {\n    const { page = 1, q } = (request.query as unknown) as IQueryParams;\n\n    const messagesRepository = getCustomRepository(MessagesRepository);\n\n    const [messages, total] = await messagesRepository.findAndCount({\n      select: ['id', 'status', 'from', 'to', 'message', 'schedule_date', 'created_at', 'updated_at'],\n      take: RES_PER_PAGE,\n      skip: (page - 1) * RES_PER_PAGE,\n      where: q && { status: q },\n      order: { created_at: 'DESC' },\n    });\n\n    const pages = Math.ceil(total / RES_PER_PAGE);\n\n    return response.json({\n      total,\n      pages,\n      limit: RES_PER_PAGE,\n      page: Number(page),\n      docs: messages,\n    });\n  }\n\n  public async show(request: Request, response: Response): Promise<Response> {\n    const messagesRepository = getCustomRepository(MessagesRepository);\n    const messages = await messagesRepository.findOne(request.params.id);\n\n    if (!messages) {\n      throw new AppError('Message not found', 404);\n    }\n\n    return response.json(messages);\n  }\n\n  public async delete(request: Request, response: Response): Promise<Response> {\n    const messagesRepository = getCustomRepository(MessagesRepository);\n    const message = await messagesRepository.findOne(request.params.id);\n\n    if (!message) {\n      throw new AppError('Message not found', 404);\n    }\n\n    if (message.status !== 'WAITING') {\n      throw new AppError('The message has already been processed');\n    }\n\n    messagesRepository.delete(message);\n\n    return response.status(200).send();\n  }\n}\n\n\nimport { Request, Response } from 'express';\nimport fs from 'fs';\nimport AppError from '../errors/AppError';\n\nexport default class TokensController {\n  public async index(_: Request, response: Response): Promise<Response> {\n    try {\n      const image = fs.readFileSync('./screenshot.png', 'base64');\n      const imageBuffer = Buffer.from(image, 'base64');\n\n      response.writeHead(200, {\n        'Content-Type': 'image/png',\n        'Content-Length': imageBuffer.length,\n      });\n      response.end(imageBuffer);\n\n      return response.status(200).send();\n\n    } catch (error) {\n      throw new AppError('Secreenshot not found', 404);\n    }\n  }\n}\n\n\nimport { Request, Response } from 'express';\nimport AuthenticationUserService from '../services/AuthenticateUserService';\n\nexport default class SessionsController {\n  public async create(request: Request, response: Response): Promise<Response> {\n    const { username, password } = request.body;\n    const authenticateUser = new AuthenticationUserService();\n\n    const { user, token, expires } = await authenticateUser.execute({\n      username,\n      password,\n    });\n\n    const userWithoutKey = {\n      id: user.id,\n      name: user.username,\n    };\n\n    return response.json({ user: userWithoutKey, token, expires });\n  }\n}\n\n\nimport { Request, Response } from 'express';\nimport { getCustomRepository, getRepository } from 'typeorm';\nimport AppError from '../errors/AppError';\nimport Token from '../models/Token';\nimport TokensRepository from '../repositories/TokensRepository';\nimport Whatsapp from '../whatsapp/client';\n\nexport default class TokensController {\n  private whatsapp: Whatsapp;\n\n  public async create(request: Request, response: Response): Promise<Response> {\n    const { from } = request.body;\n    if (!this.whatsapp) {\n      this.whatsapp = new Whatsapp();\n    }\n\n    const tokenRepository = getCustomRepository(TokensRepository);\n    await tokenRepository.deleteByPhone(process.env.DEFAULT_DDI + from);\n\n    const qrCode = await this.whatsapp.registerNewToken(from);\n\n    const image = qrCode.replace('data:image/png;base64,', '');\n    const imageBuffer = Buffer.from(image, 'base64');\n\n    response.writeHead(200, {\n      'Content-Type': 'image/png',\n      'Content-Length': imageBuffer.length,\n    });\n    response.end(imageBuffer);\n\n    return response.status(200).send();\n  }\n\n  public async index(_: Request, response: Response): Promise<Response> {\n    const tokenRepository = getRepository(Token);\n    const tokens = await tokenRepository.find();\n\n    return response.json(tokens);\n  }\n\n  public async delete(request: Request, response: Response): Promise<Response> {\n    if (!this.whatsapp) {\n      this.whatsapp = new Whatsapp();\n    }\n\n    const phone = `${process.env.DEFAULT_DDI}${request.params.phone}`;\n\n    await this.whatsapp.deleteSessionPath(phone);\n\n    const tokenRepository = getCustomRepository(TokensRepository);\n\n    const token = await tokenRepository.findByPhone(phone);\n\n    if (!token) {\n      throw new AppError('Token not found', 404);\n    }\n\n    await tokenRepository.delete(token);\n\n    return response.status(200).send();\n  }\n}\n\n\nimport { Request, Response } from 'express';\nimport { getRepository } from 'typeorm';\nimport AppError from '../errors/AppError';\nimport User from '../models/User';\nimport CreateUserService from '../services/CreateUserService';\n\nexport default class UsersController {\n  public async create(request: Request, response: Response): Promise<Response> {\n    const { username, password, admin } = request.body;\n\n    const createUser = new CreateUserService();\n\n    const user = await createUser.execute({\n      username,\n      password,\n      admin,\n    });\n\n    const userWithoutPassword = {\n      id: user.id,\n      name: user.username,\n      admin: user.admin,\n    };\n\n    return response.json(userWithoutPassword);\n  }\n\n  public async delete(request: Request, response: Response): Promise<Response> {\n    const { id } = request.params;\n\n    const userRepository = getRepository(User);\n\n    const user = await userRepository.findOne(id);\n\n    if (!user) {\n      throw new AppError('User not found', 404);\n    }\n\n    return response.status(200).send();\n  }\n}\n\nðŸ›  Generating OpenAPI spec, Please standby...\nPrompt =>  Generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 \n    standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects \n    including endpoints, return types, detailed explanations of each endpoint's purpose and functionality, \n    potential error codes, and any other relevant information essential for understanding and implementing the API.\n     here is basic information about the api documenation:\n    title: whatsapp-api-api-doc,\n    version: 0.0.1,\n    description: This API allow send messages using whatsapp through an API Rest. The project is separated by two main process, one for the API Rest and other responsible for check if there is new messages to send in the queue. Remember: This software is only for study purposes and you have to be careful to not be banned for sending spam using whatsapp. (Send spam through Whatsapp is illegal).,\n    termsOfService: #,\n    contact: {\n  \"name\": \"felipeDS91\",\n  \"email\": \"felipe.ds@outlook.com\",\n  \"url\": \"https://github.com/felipeDS91\"\n},\n    license: {\n  \"name\": \"MIT\",\n  \"url\": \"https://github.com/felipeDS91/whatsapp-api/blob/main/LICENSE\"\n},\n    servers: [\n  {\n    \"url\": \"localhost:8080\",\n    \"description\": \"local development server\"\n  }\n],\n     here are all the endpointsimport { Router } from 'express';\nimport messagesRouter from './messages.routes';\nimport usersRouter from './users.routes';\nimport sessionsRouter from './sessions.routes';\nimport tokensRouter from './tokens.routes';\nimport contactsRouter from './contacts.routes';\nimport screenshotRouter from './screenshot.routes';\n\nimport ensureAuthenticated from '../middlewares/ensureAuthenticated';\nimport ensureAdminOnly from '../middlewares/ensureAdminOnly';\n\nconst routes = Router();\n\nroutes.use('/sessions', sessionsRouter);\n\nroutes.use(ensureAuthenticated);\n\nroutes.use('/messages', messagesRouter);\nroutes.use('/users', ensureAdminOnly, usersRouter);\nroutes.use('/tokens', ensureAdminOnly, tokensRouter);\nroutes.use('/contacts', ensureAdminOnly, contactsRouter);\nroutes.use('/screenshot', ensureAdminOnly, screenshotRouter);\n\nexport default routes;\n\n\nimport { Router } from 'express';\nimport ContactsController from '../controllers/ContactsController';\n\nconst contactsRouter = Router();\nconst contactController = new ContactsController();\n\ncontactsRouter.get('/:phoneNumber', contactController.index);\n\nexport default contactsRouter;\n\n\nimport { Router } from 'express';\nimport MessagesController from '../controllers/MessagesController';\n\nconst messagesRouter = Router();\nconst messageController = new MessagesController();\n\nmessagesRouter.get('/', messageController.index);\n\nmessagesRouter.get('/:id', messageController.show);\n\nmessagesRouter.delete('/:id', messageController.delete);\n\nmessagesRouter.post('/', messageController.create);\n\nexport default messagesRouter;\n\n\nimport { Router } from 'express';\nimport ScreenshotController from '../controllers/ScreenshotController';\n\nconst screenshotRouter = Router();\nconst screenshotController = new ScreenshotController();\n\nscreenshotRouter.get('/', screenshotController.index);\n\nexport default screenshotRouter;\n\n\nimport { Router } from 'express';\n\nimport SessionsController from '../controllers/SessionsController';\n\nconst sessionsRouter = Router();\nconst sessionsController = new SessionsController();\n\nsessionsRouter.post('/', sessionsController.create);\n\nexport default sessionsRouter;\n\n\nimport { Router } from 'express';\nimport TokensController from '../controllers/TokensController';\n\nconst tokensRouter = Router();\nconst tokenController = new TokensController();\n\ntokensRouter.post('/', tokenController.create);\n\ntokensRouter.get('/', tokenController.index);\n\ntokensRouter.delete('/:phone', tokenController.delete);\n\nexport default tokensRouter;\n\n\nimport { Router } from 'express';\nimport UsersController from '../controllers/UsersController';\n\nconst usersRouter = Router();\nconst userController = new UsersController();\n\nusersRouter.post('/', userController.create);\n\nusersRouter.delete('/', userController.delete);\n\nexport default usersRouter;\n\n\n\n and here are all \n    the implementations: import { Request, Response } from 'express';\nimport Whatsapp from '../whatsapp/client';\n\nexport default class ContactsController {\n  private whatsapp: Whatsapp;\n\n  public async index(request: Request, response: Response): Promise<Response> {\n    const { phoneNumber } = request.params;\n    const onlyGroup = request.query.onlyGroup === 'true';\n\n    if (!this.whatsapp) {\n      this.whatsapp = new Whatsapp();\n    }\n\n    const contacts = (await this.whatsapp.getContacts(phoneNumber))\n      .filter(contact => (onlyGroup ? contact.isGroup : true))\n      .map(contact => ({ id: contact.id.user, name: contact.name }));\n\n    return response.json({ contacts });\n  }\n}\n\n\nimport { parseISO } from 'date-fns';\nimport { Request, Response } from 'express';\nimport { getCustomRepository } from 'typeorm';\nimport AppError from '../errors/AppError';\nimport MessagesRepository from '../repositories/MessagesRepository';\nimport CreateMessageService from '../services/CreateMessageService';\n\nconst RES_PER_PAGE = 10;\n\ninterface IQueryParams {\n  page: number;\n  q: string;\n}\n\nexport default class MessagesController {\n  public async create(request: Request, response: Response): Promise<Response> {\n    const { from, to, message, image, schedule_date } = request.body;\n\n    const parsedScheduleDate = schedule_date\n      ? parseISO(schedule_date)\n      : undefined;\n\n    const createMessage = new CreateMessageService();\n\n    const newMessage = await createMessage.execute({\n      from,\n      to,\n      message,\n      image,\n      schedule_date: parsedScheduleDate,\n    });\n\n    return response.json(newMessage);\n  }\n\n  public async index(request: Request, response: Response): Promise<Response> {\n    const { page = 1, q } = (request.query as unknown) as IQueryParams;\n\n    const messagesRepository = getCustomRepository(MessagesRepository);\n\n    const [messages, total] = await messagesRepository.findAndCount({\n      select: ['id', 'status', 'from', 'to', 'message', 'schedule_date', 'created_at', 'updated_at'],\n      take: RES_PER_PAGE,\n      skip: (page - 1) * RES_PER_PAGE,\n      where: q && { status: q },\n      order: { created_at: 'DESC' },\n    });\n\n    const pages = Math.ceil(total / RES_PER_PAGE);\n\n    return response.json({\n      total,\n      pages,\n      limit: RES_PER_PAGE,\n      page: Number(page),\n      docs: messages,\n    });\n  }\n\n  public async show(request: Request, response: Response): Promise<Response> {\n    const messagesRepository = getCustomRepository(MessagesRepository);\n    const messages = await messagesRepository.findOne(request.params.id);\n\n    if (!messages) {\n      throw new AppError('Message not found', 404);\n    }\n\n    return response.json(messages);\n  }\n\n  public async delete(request: Request, response: Response): Promise<Response> {\n    const messagesRepository = getCustomRepository(MessagesRepository);\n    const message = await messagesRepository.findOne(request.params.id);\n\n    if (!message) {\n      throw new AppError('Message not found', 404);\n    }\n\n    if (message.status !== 'WAITING') {\n      throw new AppError('The message has already been processed');\n    }\n\n    messagesRepository.delete(message);\n\n    return response.status(200).send();\n  }\n}\n\n\nimport { Request, Response } from 'express';\nimport fs from 'fs';\nimport AppError from '../errors/AppError';\n\nexport default class TokensController {\n  public async index(_: Request, response: Response): Promise<Response> {\n    try {\n      const image = fs.readFileSync('./screenshot.png', 'base64');\n      const imageBuffer = Buffer.from(image, 'base64');\n\n      response.writeHead(200, {\n        'Content-Type': 'image/png',\n        'Content-Length': imageBuffer.length,\n      });\n      response.end(imageBuffer);\n\n      return response.status(200).send();\n\n    } catch (error) {\n      throw new AppError('Secreenshot not found', 404);\n    }\n  }\n}\n\n\nimport { Request, Response } from 'express';\nimport AuthenticationUserService from '../services/AuthenticateUserService';\n\nexport default class SessionsController {\n  public async create(request: Request, response: Response): Promise<Response> {\n    const { username, password } = request.body;\n    const authenticateUser = new AuthenticationUserService();\n\n    const { user, token, expires } = await authenticateUser.execute({\n      username,\n      password,\n    });\n\n    const userWithoutKey = {\n      id: user.id,\n      name: user.username,\n    };\n\n    return response.json({ user: userWithoutKey, token, expires });\n  }\n}\n\n\nimport { Request, Response } from 'express';\nimport { getCustomRepository, getRepository } from 'typeorm';\nimport AppError from '../errors/AppError';\nimport Token from '../models/Token';\nimport TokensRepository from '../repositories/TokensRepository';\nimport Whatsapp from '../whatsapp/client';\n\nexport default class TokensController {\n  private whatsapp: Whatsapp;\n\n  public async create(request: Request, response: Response): Promise<Response> {\n    const { from } = request.body;\n    if (!this.whatsapp) {\n      this.whatsapp = new Whatsapp();\n    }\n\n    const tokenRepository = getCustomRepository(TokensRepository);\n    await tokenRepository.deleteByPhone(process.env.DEFAULT_DDI + from);\n\n    const qrCode = await this.whatsapp.registerNewToken(from);\n\n    const image = qrCode.replace('data:image/png;base64,', '');\n    const imageBuffer = Buffer.from(image, 'base64');\n\n    response.writeHead(200, {\n      'Content-Type': 'image/png',\n      'Content-Length': imageBuffer.length,\n    });\n    response.end(imageBuffer);\n\n    return response.status(200).send();\n  }\n\n  public async index(_: Request, response: Response): Promise<Response> {\n    const tokenRepository = getRepository(Token);\n    const tokens = await tokenRepository.find();\n\n    return response.json(tokens);\n  }\n\n  public async delete(request: Request, response: Response): Promise<Response> {\n    if (!this.whatsapp) {\n      this.whatsapp = new Whatsapp();\n    }\n\n    const phone = `${process.env.DEFAULT_DDI}${request.params.phone}`;\n\n    await this.whatsapp.deleteSessionPath(phone);\n\n    const tokenRepository = getCustomRepository(TokensRepository);\n\n    const token = await tokenRepository.findByPhone(phone);\n\n    if (!token) {\n      throw new AppError('Token not found', 404);\n    }\n\n    await tokenRepository.delete(token);\n\n    return response.status(200).send();\n  }\n}\n\n\nimport { Request, Response } from 'express';\nimport { getRepository } from 'typeorm';\nimport AppError from '../errors/AppError';\nimport User from '../models/User';\nimport CreateUserService from '../services/CreateUserService';\n\nexport default class UsersController {\n  public async create(request: Request, response: Response): Promise<Response> {\n    const { username, password, admin } = request.body;\n\n    const createUser = new CreateUserService();\n\n    const user = await createUser.execute({\n      username,\n      password,\n      admin,\n    });\n\n    const userWithoutPassword = {\n      id: user.id,\n      name: user.username,\n      admin: user.admin,\n    };\n\n    return response.json(userWithoutPassword);\n  }\n\n  public async delete(request: Request, response: Response): Promise<Response> {\n    const { id } = request.params;\n\n    const userRepository = getRepository(User);\n\n    const user = await userRepository.findOne(id);\n\n    if (!user) {\n      throw new AppError('User not found', 404);\n    }\n\n    return response.status(200).send();\n  }\n}",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n      \"title\": \"whatsapp-api-doc\",\n      \"version\": \"0.0.1\",\n      \"description\": \"This API allows sending messages using WhatsApp through a REST API. The project is separated into two main processes, one for the REST API and the other responsible for checking if there are new messages to send in the queue. Remember: This software is only for study purposes and you have to be careful to not be banned for sending spam using WhatsApp. (Sending spam through WhatsApp is illegal).\",\n      \"termsOfService\": \"#\",\n      \"contact\": {\n        \"name\": \"felipeDS91\",\n        \"email\": \"felipe.ds@outlook.com\",\n        \"url\": \"https://github.com/felipeDS91\"\n      },\n      \"license\": {\n        \"name\": \"MIT\",\n        \"url\": \"https://github.com/felipeDS91/whatsapp-api/blob/main/LICENSE\"\n      }\n    },\n    \"servers\": [\n      {\n        \"url\": \"http://localhost:8080\",\n        \"description\": \"Local development server\"\n      }\n    ],\n    \"paths\": {\n      \"/sessions\": {\n        \"post\": {\n          \"summary\": \"Create a new session\",\n          \"description\": \"Authenticate user and create a new session\",\n          \"tags\": [\"Sessions\"],\n          \"requestBody\": {\n            \"required\": true,\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"username\": { \"type\": \"string\" },\n                    \"password\": { \"type\": \"string\" }\n                  },\n                  \"required\": [\"username\", \"password\"]\n                }\n              }\n            }\n          },\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Session created successfully\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"user\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                          \"id\": { \"type\": \"string\" },\n                          \"name\": { \"type\": \"string\" }\n                        }\n                      },\n                      \"token\": { \"type\": \"string\" },\n                      \"expires\": { \"type\": \"string\", \"format\": \"date-time\" }\n                    }\n                  }\n                }\n              }\n            },\n            \"401\": { \"description\": \"Unauthorized\" },\n            \"500\": { \"description\": \"Internal Server Error\" }\n          }\n        }\n      },\n      \"/messages\": {\n        \"get\": {\n          \"summary\": \"Get messages\",\n          \"description\": \"Retrieve a paginated list of messages\",\n          \"tags\": [\"Messages\"],\n          \"parameters\": [\n            {\n              \"name\": \"page\",\n              \"in\": \"query\",\n              \"schema\": { \"type\": \"integer\", \"default\": 1 },\n              \"description\": \"Page number\"\n            },\n            {\n              \"name\": \"q\",\n              \"in\": \"query\",\n              \"schema\": { \"type\": \"string\" },\n              \"description\": \"Message status query\"\n            }\n          ],\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Messages retrieved successfully\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"total\": { \"type\": \"integer\" },\n                      \"pages\": { \"type\": \"integer\" },\n                      \"limit\": { \"type\": \"integer\" },\n                      \"page\": { \"type\": \"integer\" },\n                      \"docs\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                          \"type\": \"object\",\n                          \"properties\": {\n                            \"id\": { \"type\": \"string\" },\n                            \"status\": { \"type\": \"string\" },\n                            \"from\": { \"type\": \"string\" },\n                            \"to\": { \"type\": \"string\" },\n                            \"message\": { \"type\": \"string\" },\n                            \"schedule_date\": { \"type\": \"string\", \"format\": \"date-time\" },\n                            \"created_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n                            \"updated_at\": { \"type\": \"string\", \"format\": \"date-time\" }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            \"500\": { \"description\": \"Internal Server Error\" }\n          }\n        },\n        \"post\": {\n          \"summary\": \"Create a message\",\n          \"description\": \"Create a new message to send\",\n          \"tags\": [\"Messages\"],\n          \"requestBody\": {\n            \"required\": true,\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"from\": { \"type\": \"string\" },\n                    \"to\": { \"type\": \"string\" },\n                    \"message\": { \"type\": \"string\" },\n                    \"image\": { \"type\": \"string\", \"format\": \"binary\" },\n                    \"schedule_date\": { \"type\": \"string\", \"format\": \"date-time\" }\n                  },\n                  \"required\": [\"from\", \"to\", \"message\"]\n                }\n              }\n            }\n          },\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Message created successfully\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"id\": { \"type\": \"string\" },\n                      \"from\": { \"type\": \"string\" },\n                      \"to\": { \"type\": \"string\" },\n                      \"message\": { \"type\": \"string\" },\n                      \"image\": { \"type\": \"string\" },\n                      \"schedule_date\": { \"type\": \"string\", \"format\": \"date-time\" }\n                    }\n                  }\n                }\n              }\n            },\n            \"400\": { \"description\": \"Bad Request\" },\n            \"500\": { \"description\": \"Internal Server Error\" }\n          }\n        }\n      },\n      \"/messages/{id}\": {\n        \"get\": {\n          \"summary\": \"Get a specific message\",\n          \"description\": \"Retrieve details of a specific message by ID\",\n          \"tags\": [\"Messages\"],\n          \"parameters\": [\n            {\n              \"name\": \"id\",\n              \"in\": \"path\",\n              \"required\": true,\n              \"schema\": { \"type\": \"string\" },\n              \"description\": \"Message ID\"\n            }\n          ],\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Message retrieved successfully\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"id\": { \"type\": \"string\" },\n                      \"status\": { \"type\": \"string\" },\n                      \"from\": { \"type\": \"string\" },\n                      \"to\": { \"type\": \"string\" },\n                      \"message\": { \"type\": \"string\" },\n                      \"schedule_date\": { \"type\": \"string\", \"format\": \"date-time\" },\n                      \"created_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n                      \"updated_at\": { \"type\": \"string\", \"format\": \"date-time\" }\n                    }\n                  }\n                }\n              }\n            },\n            \"404\": { \"description\": \"Message not found\" },\n            \"500\": { \"description\": \"Internal Server Error\" }\n          }\n        },\n        \"delete\": {\n          \"summary\": \"Delete a message\",\n          \"description\": \"Delete a specific message by ID\",\n          \"tags\": [\"Messages\"],\n          \"parameters\": [\n            {\n              \"name\": \"id\",\n              \"in\": \"path\",\n              \"required\": true,\n              \"schema\": { \"type\": \"string\" },\n              \"description\": \"Message ID\"\n            }\n          ],\n          \"responses\": {\n            \"200\": { \"description\": \"Message deleted successfully\" },\n            \"404\": { \"description\": \"Message not found\" },\n            \"409\": { \"description\": \"The message has already been processed\" },\n            \"500\": { \"description\": \"Internal Server Error\" }\n          }\n        }\n      },\n      \"/contacts/{phoneNumber}\": {\n        \"get\": {\n          \"summary\": \"Get contacts\",\n          \"description\": \"Retrieve a list of contacts for a given phone number\",\n          \"tags\": [\"Contacts\"],\n          \"parameters\": [\n            {\n              \"name\": \"phoneNumber\",\n              \"in\": \"path\",\n              \"required\": true,\n              \"schema\": { \"type\": \"string\" },\n              \"description\": \"Phone number to retrieve contacts for\"\n            },\n            {\n              \"name\": \"onlyGroup\",\n              \"in\": \"query\",\n              \"schema\": { \"type\": \"boolean\" },\n              \"description\": \"Filter to only include group contacts\"\n            }\n          ],\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Contacts retrieved successfully\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"contacts\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                          \"type\": \"object\",\n                          \"properties\": {\n                            \"id\": { \"type\": \"string\" },\n                            \"name\": { \"type\": \"string\" },\n                            \"status\": { \"type\": \"string\" }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            \"404\": { \"description\": \"Contacts not found\" },\n            \"500\": { \"description\": \"Internal Server Error\" }\n          }\n        }\n      },\n      \"/users\": {\n      \"post\": {\n            \"summary\": \"Create a new user\",\n            \"description\": \"Create a new user with username, password, and admin status\",\n            \"tags\": [\"Users\"],\n            \"requestBody\": {\n            \"required\": true,\n            \"content\": {\n                \"application/json\": {\n                \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                    \"username\": { \"type\": \"string\" },\n                    \"password\": { \"type\": \"string\" },\n                    \"admin\": { \"type\": \"boolean\" }\n                    },\n                    \"required\": [\"username\", \"password\"]\n                }\n                }\n            }\n            },\n            \"responses\": {\n            \"200\": {\n                \"description\": \"User created successfully\",\n                \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": { \"type\": \"string\" },\n                        \"username\": { \"type\": \"string\" },\n                        \"admin\": { \"type\": \"boolean\" }\n                    }\n                    }\n                }\n                }\n            },\n            \"500\": { \"description\": \"Internal Server Error\" }\n            }\n        },\n            \"delete\": {\n                \"summary\": \"Delete a user\",\n                \"description\": \"Delete a user by ID\",\n                \"tags\": [\"Users\"],\n                \"parameters\": [\n                {\n                    \"name\": \"id\",\n                    \"in\": \"path\",\n                    \"required\": true,\n                    \"schema\": { \"type\": \"string\" },\n                    \"description\": \"User ID\"\n                }\n                ],\n                \"responses\": {\n                \"200\": { \"description\": \"User deleted successfully\" },\n                \"404\": { \"description\": \"User not found\" },\n                \"500\": { \"description\": \"Internal Server Error\" }\n                }\n            }\n        },\n        \"/tokens\": {\n        \"post\": {\n            \"summary\": \"Create a new token\",\n            \"description\": \"Generate a new authentication token\",\n            \"tags\": [\"Tokens\"],\n            \"requestBody\": {\n            \"required\": true,\n            \"content\": {\n                \"application/json\": {\n                \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                    \"from\": { \"type\": \"string\" }\n                    },\n                    \"required\": [\"from\"]\n                }\n                }\n            }\n            },\n            \"responses\": {\n            \"200\": {\n                \"description\": \"Token created successfully\",\n                \"content\": {\n                \"image/png\": {\n                    \"schema\": {\n                    \"type\": \"string\",\n                    \"format\": \"binary\"\n                    }\n                }\n                }\n            },\n            \"500\": { \"description\": \"Internal Server Error\" }\n            }\n        }\n        },\n        \"/tokens/{phone}\": {\n        \"delete\": {\n            \"summary\": \"Delete a token\",\n            \"description\": \"Invalidate a specific token by phone number\",\n            \"tags\": [\"Tokens\"],\n            \"parameters\": [\n            {\n                \"name\": \"phone\",\n                \"in\": \"path\",\n                \"required\": true,\n                \"schema\": { \"type\": \"string\" },\n                \"description\": \"Phone number associated with the token to invalidate\"\n            }\n            ],\n            \"responses\": {\n            \"200\": { \"description\": \"Token invalidated successfully\" },\n            \"404\": { \"description\": \"Token not found\" },\n            \"500\": { \"description\": \"Internal Server Error\" }\n            }\n        }\n        },\n        \"/screenshot\": {\n            \"get\": {\n                \"summary\": \"Get screenshot\",\n                \"description\": \"Retrieve the screenshot of the WhatsApp session\",\n                \"tags\": [\"Screenshot\"],\n                \"responses\": {\n                \"200\": {\n                    \"description\": \"Successful operation\",\n                    \"content\": {\n                    \"image/png\": {\n                        \"schema\": {\n                        \"type\": \"string\",\n                        \"format\": \"binary\"\n                        }\n                    }\n                    }\n                },\n                \"404\": {\n                    \"description\": \"Screenshot not found\"\n                },\n                \"500\": {\n                    \"description\": \"Internal Server Error\"\n                }\n                }\n            }\n        }\n    },\n    \"components\": {\n    \"schemas\": {\n        \"Session\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"username\": { \"type\": \"string\" },\n            \"password\": { \"type\": \"string\" }\n        }\n        },\n        \"Message\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"from\": { \"type\": \"string\" },\n            \"to\": { \"type\": \"string\" },\n            \"message\": { \"type\": \"string\" },\n            \"image\": { \"type\": \"string\" },\n            \"schedule_date\": { \"type\": \"string\", \"format\": \"date-time\" }\n        }\n        },\n        \"Contact\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"id\": { \"type\": \"string\" },\n            \"name\": { \"type\": \"string\" },\n            \"status\": { \"type\": \"string\" }\n        }\n        },\n        \"User\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"id\": { \"type\": \"string\" },\n            \"name\": { \"type\": \"string\" },\n            \"admin\": { \"type\": \"boolean\" }\n        }\n        }\n    }\n    },\n    \"tags\": [\n      { \"name\": \"Sessions\", \"description\": \"Operations related to user sessions\" },\n      { \"name\": \"Messages\", \"description\": \"Operations related to messages\" },\n      { \"name\": \"Contacts\", \"description\": \"Operations related to contacts\" },\n      { \"name\": \"Users\", \"description\": \"Operations related to users\" },\n      { \"name\": \"Tokens\", \"description\": \"Operations related to authentication tokens\" },\n      { \"name\": \"Screenshot\", \"description\": \"Operations related to capturing screenshots\" }\n    ]\n  }  [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nconst router = require('express').Router()\n\nconst { BaseController } = require('../../rootcommmon/BaseController')\nconst actions = require('./actions')\n\nclass AuthController extends BaseController {\n  get router () {\n    router.post('/auth/login', this.actionRunner(actions.LoginAction))\n    router.post('/auth/logout', this.actionRunner(actions.LogoutAction))\n    router.post('/auth/refresh-tokens', this.actionRunner(actions.RefreshTokensAction))\n\n    return router\n  }\n\n  async init () {\n    this.logger.debug(`${this.constructor.name} initialized...`)\n  }\n}\n\nmodule.exports = { AuthController }\n\n\nconst router = require('express').Router()\n\nconst actions = require('./actions')\nconst { BaseController } = require('../../rootcommmon/BaseController')\n\nclass PostsController extends BaseController {\n  get router () {\n    router.param('id', preparePostId)\n\n    router.get('/posts', this.actionRunner(actions.ListPostsAction))\n    router.get('/posts/:id', this.actionRunner(actions.GetPostByIdAction))\n    router.post('/posts', this.actionRunner(actions.CreatePostAction))\n    router.patch('/posts/:id', this.actionRunner(actions.UpdatePostAction))\n    router.delete('/posts/:id', this.actionRunner(actions.RemovePostAction))\n\n    return router\n  }\n\n  async init () {\n    this.logger.debug(`${this.constructor.name} initialized...`)\n  }\n}\n\nfunction preparePostId (req, res, next) {\n  const id = Number(req.params.id)\n  if (id) req.params.id = id\n  next()\n}\n\nmodule.exports = { PostsController }\n\n\nconst router = require('express').Router()\n\nconst actions = require('./actions')\nconst { BaseController } = require('../../rootcommmon/BaseController')\n\nclass UsersController extends BaseController {\n  get router () {\n    router.get('/users', this.actionRunner(actions.ListUsersAction))\n    router.get('/users/current', this.actionRunner(actions.GetCurrentUserAction))\n    router.get('/users/:id', this.actionRunner(actions.GetUserByIdAction))\n    router.post('/users', this.actionRunner(actions.CreateUserAction))\n    router.patch('/users', this.actionRunner(actions.UpdateUserAction))\n    router.delete('/users/:id', this.actionRunner(actions.RemoveUserAction))\n\n    router.post('/users/change-password', this.actionRunner(actions.ChangePasswordAction))\n    router.post('/users/send-reset-password-email', this.actionRunner(actions.SendResetPasswordEmailAction))\n    router.post('/users/reset-password', this.actionRunner(actions.ResetPasswordAction))\n\n    router.post('/users/confirm-registration', this.actionRunner(actions.ConfirmRegistrationAction))\n    router.post('/users/change-email', this.actionRunner(actions.ChangeEmailAction))\n    router.post('/users/confirm-email', this.actionRunner(actions.ConfirmEmailAction))\n    router.post('/users/resend-confirm-new-email-token', this.actionRunner(actions.ResendConfirmNewEmailTokenAction))\n    router.post('/users/cancel-email-changing', this.actionRunner(actions.CancelEmailChangingAction))\n\n    return router\n  }\n\n  async init () {\n    this.logger.debug(`${this.constructor.name} initialized...`)\n  }\n}\n\nmodule.exports = { UsersController }\n\n\n\nconst express = require('express')\nconst router = express.Router()\n\nconst { BaseController } = require('../../rootcommmon/BaseController')\nconst RootProvider = require('../RootProvider')\n\nclass RootController extends BaseController {\n  get router () {\n    router.get('/', (req, res) => {\n      res.json({ success: true, message: '(>___<)' })\n    })\n\n    return router\n  }\n\n  async init () {\n    this.logger.debug(`${this.constructor.name} initialized...`)\n    await RootProvider.init()\n  }\n}\n\nmodule.exports = { RootController }\n\nBelow are the implementations:\n\nconst ms = require('ms')\nconst { v4: uuidv4 } = require('uuid')\nconst { RequestRule, AppError, errorCodes, CookieEntity } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { addRefreshSession } = require('../common/addRefreshSession')\nconst { UserDAO } = require('../../../dao/UserDAO')\nconst { AuthModel } = require('../../../models/AuthModel')\nconst { RefreshSessionEntity } = require('../common/RefreshSessionEntity')\nconst { makeAccessToken } = require('../common/makeAccessToken')\nconst { checkPassword } = require('../../../rootcommmon/checkPassword')\nconst config = require('../../../config')\n\nclass LoginAction extends BaseAction {\n  static get accessTag () {\n    return 'auth:login'\n  }\n\n  static get validationRules () {\n    return {\n      body: {\n        password: new RequestRule(AuthModel.schema.password, { required: true }),\n        email: new RequestRule(AuthModel.schema.email, { required: true }),\n        fingerprint: new RequestRule(AuthModel.schema.fingerprint, { required: true })\n      }\n    }\n  }\n\n  static async run (ctx) {\n    let user = {}\n    const refTokenExpiresInMilliseconds = new Date().getTime() + ms(config.token.refresh.expiresIn)\n    const refTokenExpiresInSeconds = parseInt(refTokenExpiresInMilliseconds / 1000)\n\n    try {\n      user = await UserDAO.getByEmail(ctx.body.email)\n      await checkPassword(ctx.body.password, user.passwordHash)\n    } catch (e) {\n      if ([errorCodes.NOT_FOUND.code, errorCodes.INVALID_PASSWORD.code].includes(e.code)) {\n        throw new AppError({ ...errorCodes.INVALID_CREDENTIALS })\n      }\n      throw e\n    }\n\n    const newRefreshSession = new RefreshSessionEntity({\n      refreshToken: uuidv4(),\n      userId: user.id,\n      ip: ctx.ip,\n      ua: ctx.headers['User-Agent'],\n      fingerprint: ctx.body.fingerprint,\n      expiresIn: refTokenExpiresInMilliseconds\n    })\n\n    await addRefreshSession(newRefreshSession)\n\n    return this.result({\n      data: {\n        accessToken: await makeAccessToken(user),\n        refreshToken: newRefreshSession.refreshToken\n      },\n      cookies: [\n        new CookieEntity({\n          name: 'refreshToken',\n          value: newRefreshSession.refreshToken,\n          domain: 'localhost',\n          path: '/auth',\n          maxAge: refTokenExpiresInSeconds,\n          secure: false // temp: should be deleted\n        })\n      ]\n    })\n  }\n}\n\nmodule.exports = { LoginAction }\n\n\nconst { RequestRule, AppError, errorCodes } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { RefreshSessionDAO } = require('../../../dao/RefreshSessionDAO')\nconst { AuthModel } = require('../../../models/AuthModel')\n\n/**\n * remove current session\n */\nclass LogoutAction extends BaseAction {\n  static get accessTag () {\n    return 'auth:logout'\n  }\n\n  static get validationRules () {\n    return {\n      body: {\n        refreshToken: new RequestRule(AuthModel.schema.refreshToken)\n      },\n      cookies: {\n        refreshToken: new RequestRule(AuthModel.schema.refreshToken)\n      }\n    }\n  }\n\n  static async run (ctx) {\n    // take refresh token from any possible source\n    const refreshToken = ctx.cookies.refreshToken || ctx.body.refreshToken\n    if (!refreshToken) {\n      throw new AppError({ ...errorCodes.VALIDATION, message: 'Refresh token not provided' })\n    }\n\n    await RefreshSessionDAO.baseRemoveWhere({ refreshToken })\n\n    return this.result({ message: 'User is logged out from current session.' })\n  }\n}\n\nmodule.exports = { LogoutAction }\n\n\nconst ms = require('ms')\nconst { v4: uuidv4 } = require('uuid')\nconst { RequestRule, CookieEntity, AppError, errorCodes } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { addRefreshSession } = require('../common/addRefreshSession')\nconst { verifyRefreshSession } = require('../common/verifyRefreshSession')\nconst { makeAccessToken } = require('../common/makeAccessToken')\nconst { RefreshSessionEntity } = require('../common/RefreshSessionEntity')\nconst { UserDAO } = require('../../../dao/UserDAO')\nconst { AuthModel } = require('../../../models/AuthModel')\nconst { RefreshSessionDAO } = require('../../../dao/RefreshSessionDAO')\nconst config = require('../../../config')\n\nclass RefreshTokensAction extends BaseAction {\n  static get accessTag () {\n    return 'auth:refresh-tokens'\n  }\n\n  static get validationRules () {\n    return {\n      body: {\n        fingerprint: new RequestRule(AuthModel.schema.fingerprint, { required: true }), // https://github.com/Valve/fingerprintjs2\n        refreshToken: new RequestRule(AuthModel.schema.refreshToken)\n      },\n      cookies: {\n        refreshToken: new RequestRule(AuthModel.schema.refreshToken)\n      }\n    }\n  }\n\n  static async run (ctx) {\n    // take refresh token from any possible source\n    const reqRefreshToken = ctx.cookies.refreshToken || ctx.body.refreshToken\n    const reqFingerprint = ctx.body.fingerprint\n\n    if (!reqRefreshToken) {\n      throw new AppError({ ...errorCodes.VALIDATION, message: 'Refresh token not provided' })\n    }\n\n    const refTokenExpiresInMilliseconds = new Date().getTime() + ms(config.token.refresh.expiresIn)\n    const refTokenExpiresInSeconds = parseInt(refTokenExpiresInMilliseconds / 1000)\n\n    const oldRefreshSession = await RefreshSessionDAO.getByRefreshToken(reqRefreshToken)\n    await RefreshSessionDAO.baseRemoveWhere({ refreshToken: reqRefreshToken })\n    verifyRefreshSession(new RefreshSessionEntity(oldRefreshSession), reqFingerprint)\n    const user = await UserDAO.baseGetById(oldRefreshSession.userId)\n\n    const newRefreshSession = new RefreshSessionEntity({\n      refreshToken: uuidv4(),\n      userId: user.id,\n      ip: ctx.ip,\n      ua: ctx.headers['User-Agent'],\n      fingerprint: reqFingerprint,\n      expiresIn: refTokenExpiresInMilliseconds\n    })\n\n    await addRefreshSession(newRefreshSession)\n\n    return this.result({\n      data: {\n        accessToken: await makeAccessToken(user),\n        refreshToken: newRefreshSession.refreshToken\n      },\n      cookies: [\n        new CookieEntity({\n          name: 'refreshToken',\n          value: newRefreshSession.refreshToken,\n          domain: 'localhost',\n          path: '/auth',\n          maxAge: refTokenExpiresInSeconds,\n          secure: false // temp: should be deleted\n        })\n      ]\n    })\n  }\n}\n\nmodule.exports = { RefreshTokensAction }\n\n\nconst isUUID = require('validator/lib/isUUID')\nconst { RequestRule, Rule } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { PostDAO } = require('../../../dao/PostDAO')\n\nclass ListPostsAction extends BaseAction {\n  static get accessTag () {\n    return 'posts:list'\n  }\n\n  static get validationRules () {\n    return {\n      query: {\n        ...this.baseQueryParams,\n        filter: new RequestRule(new Rule({\n          validator: v => {\n            if (v && v.userId) { return isUUID(v.userId) }\n            return true\n          },\n          description: 'filter.userId: uuid;',\n          example: 'filter[userId]=5e33250c-ce15-4bec-a623-8611573d5b82'\n        }))\n      }\n    }\n  }\n\n  static async run (ctx) {\n    const { query } = ctx\n    const data = await PostDAO.baseGetList({ ...query })\n\n    return this.result({\n      data: data.results,\n      headers: { 'X-Total-Count': data.total }\n    })\n  }\n}\n\nmodule.exports = { ListPostsAction }\n\n\nconst { RequestRule } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { PostDAO } = require('../../../dao/PostDAO')\nconst { PostModel } = require('../../../models/PostModel')\nconst { privateItemPolicy } = require('../../../policy')\n\nclass GetPostByIdAction extends BaseAction {\n  static get accessTag () {\n    return 'posts:get-by-id'\n  }\n\n  static get validationRules () {\n    return {\n      params: {\n        id: new RequestRule(PostModel.schema.id, { required: true })\n      }\n    }\n  }\n\n  static async run (ctx) {\n    const { currentUser } = ctx\n\n    const model = await PostDAO.baseGetById(ctx.params.id)\n    await privateItemPolicy(model, currentUser)\n\n    return this.result({ data: model })\n  }\n}\n\nmodule.exports = { GetPostByIdAction }\n\n\nconst { RequestRule } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { PostDAO } = require('../../../dao/PostDAO')\nconst { PostModel } = require('../../../models/PostModel')\n\nclass CreatePostAction extends BaseAction {\n  static get accessTag () {\n    return 'posts:create'\n  }\n\n  static get validationRules () {\n    return {\n      body: {\n        title: new RequestRule(PostModel.schema.title, { required: true }),\n        content: new RequestRule(PostModel.schema.content, { required: true })\n      }\n    }\n  }\n\n  static async run (ctx) {\n    const { currentUser } = ctx\n    const data = await PostDAO.baseCreate({ ...ctx.body, userId: currentUser.id })\n    return this.result({ data })\n  }\n}\n\nmodule.exports = { CreatePostAction }\n\n\nconst { RequestRule } = require('supra-core')\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\n\nconst { PostDAO } = require('../../../dao/PostDAO')\nconst { PostModel } = require('../../../models/PostModel')\nconst { ownerPolicy } = require('../../../policy')\n\nclass UpdatePostAction extends BaseAction {\n  static get accessTag () {\n    return 'posts:update'\n  }\n\n  static get validationRules () {\n    return {\n      params: {\n        id: new RequestRule(PostModel.schema.id, { required: true })\n      },\n      body: {\n        title: new RequestRule(PostModel.schema.title),\n        content: new RequestRule(PostModel.schema.content)\n      },\n      notEmptyBody: true\n    }\n  }\n\n  static async run (ctx) {\n    const { currentUser } = ctx\n\n    const model = await PostDAO.baseGetById(ctx.params.id)\n    await ownerPolicy(model, currentUser)\n    const data = await PostDAO.baseUpdate(ctx.params.id, ctx.body)\n\n    return this.result({ data })\n  }\n}\n\nmodule.exports = { UpdatePostAction }\n\n\nconst { RequestRule } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { PostDAO } = require('../../../dao/PostDAO')\nconst { PostModel } = require('../../../models/PostModel')\nconst { ownerPolicy } = require('../../../policy')\n\nclass RemovePostAction extends BaseAction {\n  static get accessTag () {\n    return 'posts:delete'\n  }\n\n  static get validationRules () {\n    return {\n      params: {\n        id: new RequestRule(PostModel.schema.id, { required: true })\n      }\n    }\n  }\n\n  static async run (ctx) {\n    const { currentUser } = ctx\n\n    const model = await PostDAO.baseGetById(ctx.params.id)\n    await ownerPolicy(model, currentUser)\n    await PostDAO.baseRemove(ctx.params.id)\n\n    return this.result({ message: `${ctx.params.id} was removed` })\n  }\n}\n\nmodule.exports = { RemovePostAction }\n\n\nconst joi = require('joi')\nconst { RequestRule, Rule } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { UserDAO } = require('../../../dao/UserDAO')\n\n/**\n * @description return users list\n */\nclass ListUsersAction extends BaseAction {\n  static get accessTag () {\n    return 'users:list'\n  }\n\n  static get validationRules () {\n    return {\n      query: {\n        ...this.baseQueryParams,\n        orderBy: new RequestRule(new Rule({\n          validator: v => {\n            const result = joi.object({\n              field: joi.string().valid('createdAt', 'username'),\n              direction: joi.string().valid('asc', 'desc')\n            }).validate(v)\n            return result.error && result.error.message || true\n          },\n          description: 'Object; { field: \\'username\\' || \\'createdAt\\', direction: \\'asc\\' || \\'desc\\' }',\n          example: 'orderBy[direction]=desc&orderBy[field]=username'\n        })),\n        filter: new RequestRule(new Rule({\n          validator: v => {\n            const result = joi.object({\n              username: joi.string().min(2)\n            }).validate(v)\n            return result.error && result.error.message || true\n          },\n          description: 'Object; { username: string; String; min 2 chars',\n          example: 'filter[username]=alex'\n        }))\n      }\n    }\n  }\n\n  static async run (req) {\n    const { query } = req\n    const data = await UserDAO.baseGetList({ ...query })\n\n    return this.result({\n      data: data.results,\n      headers: {\n        'X-Total-Count': data.total\n      }\n    })\n  }\n}\n\nmodule.exports = { ListUsersAction }\n\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { UserDAO } = require('../../../dao/UserDAO')\n\nclass GetCurrentUserAction extends BaseAction {\n  static get accessTag () {\n    return 'users:get-current-user'\n  }\n\n  static async run (ctx) {\n    const { currentUser } = ctx\n    const data = await UserDAO.getCurrentUser(currentUser.id)\n\n    return this.result({ data })\n  }\n}\n\nmodule.exports = { GetCurrentUserAction }\n\n\nconst { assert } = require('supra-core')\nconst { UserModel } = require('../models/UserModel')\nconst { UserDbDto } = require('./dto/UserDbDto')\nconst { BaseDAO } = require('./BaseDAO')\n\nclass UserDAO extends BaseDAO {\n  static get tableName () {\n    return 'users'\n  }\n\n  static get dto () {\n    return UserDbDto\n  }\n\n  static get relationMappings () {\n    return {\n      posts: {\n        relation: BaseDAO.HasManyRelation,\n        modelClass: `${__dirname}/PostDAO`,\n        join: {\n          from: 'users.id',\n          to: 'posts.userId'\n        }\n      }\n    }\n  }\n\n  /**\n   * ------------------------------\n   * @HOOKS\n   * ------------------------------\n   */\n  $formatJson (json) {\n    json = super.$formatJson(json)\n    return json\n  }\n\n  /**\n   * ------------------------------\n   * @METHODS\n   * ------------------------------\n   */\n\n  static async create (data) {\n    assert.object(data, { required: true })\n    assert.string(data.passwordHash, { notEmpty: true })\n\n    const result = await this.query().insert(data)\n\n    return this.mapObject(result)\n  };\n\n  static async getByEmail (email) {\n    assert.validate(email, UserModel.schema.email, { required: true })\n\n    const data = await this.query().where({ email }).first()\n    if (!data) throw this.errorEmptyResponse()\n    return this.mapObject(data)\n  }\n\n  static async getCurrentUser (id) {\n    assert.validate(id, UserModel.schema.id, { required: true })\n\n    const data = await this.query().findById(id)\n    if (!data) throw this.errorEmptyResponse()\n\n    // delete sensitive data from raw current user\n    delete data.passwordHash\n    delete data.emailConfirmToken\n    delete data.resetPasswordToken\n\n    return data\n  }\n\n  /**\n   * @description check email availability in DB.\n   * @param email\n   * @returns {Promise<boolean>}\n   */\n  static async isEmailExist (email) {\n    assert.validate(email, UserModel.schema.email, { required: true })\n\n    const data = await this.query().where({ email }).first()\n    return Boolean(data)\n  }\n\n  static async checkEmailAvailability (email) {\n    assert.validate(email, UserModel.schema.email, { required: true })\n\n    const data = await this.query().where({ email }).first()\n    return { available: !data }\n  }\n}\n\nmodule.exports = { UserDAO }\n\n\nconst { RequestRule } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { UserDAO } = require('../../../dao/UserDAO')\nconst { UserModel } = require('../../../models/UserModel')\n\n/**\n * @description return user by id\n */\nclass GetUserByIdAction extends BaseAction {\n  static get accessTag () {\n    return 'users:get-by-id'\n  }\n\n  static get validationRules () {\n    return {\n      params: {\n        id: new RequestRule(UserModel.schema.id, { required: true })\n      }\n    }\n  }\n\n  static async run (ctx) {\n    const model = await UserDAO.baseGetById(ctx.params.id)\n\n    return this.result({ data: model })\n  }\n}\n\nmodule.exports = { GetUserByIdAction }\n\n\nconst Model = require('objection').Model\n// https://github.com/Vincit/objection-db-errors\nconst { wrapError, UniqueViolationError, NotNullViolationError } = require('db-errors')\nconst { assert, errorCodes, AppError } = require('supra-core')\n\nclass BaseDAO extends Model {\n  /**\n   * ------------------------------\n   * @HELPERS\n   * ------------------------------\n   */\n\n  static errorEmptyResponse () {\n    return new AppError({ ...errorCodes.NOT_FOUND, layer: 'DAO' })\n  }\n\n  static emptyPageResponse () {\n    return { results: [], total: 0 }\n  }\n\n  static emptyListResponse () {\n    return []\n  }\n\n  static emptyObjectResponse () {\n    return {}\n  }\n\n  static get dto () {\n    return new AppError({\n      ...errorCodes.SERVER,\n      layer: 'DAO',\n      message: `${this.name}: missing dto getter`\n    })\n  }\n\n  /**\n   * @param data\n   * @returns {{total, results: *[]}}\n   */\n  static mapPage (data = {}) {\n    assert.array(data.results, { required: true })\n    assert.integer(data.total, { required: true })\n\n    const Dto = this.dto\n    assert.func(Dto, { required: true })\n\n    return {\n      results: data.results.map(i => new Dto(i)),\n      total: data.total || 0\n    }\n  }\n\n  /**\n   * @param data\n   * @returns {*}\n   */\n  static mapObject (data = {}) {\n    assert.object(data, { required: true })\n\n    const Dto = this.dto\n    assert.func(Dto, { required: true })\n\n    return new Dto(data)\n  }\n\n  static verifyUserId (data) {\n    assert.object(data, { required: true })\n\n    /**\n     * each entity that creates must have creator id (userId)\n     */\n    if (!data.email && !data.userId) {\n      throw new AppError({\n        ...errorCodes.UNPROCESSABLE_ENTITY,\n        message: 'Please provide in action class \\'userId\\' field',\n        layer: 'DAO'\n      })\n    }\n  }\n\n  static query () {\n    return super.query.apply(this, arguments).onError(error => {\n      return Promise.reject(wrapError(error))\n        .catch(error => {\n          error = error.nativeError || error\n\n          if (error instanceof UniqueViolationError) {\n            throw new AppError({\n              ...errorCodes.DB_DUPLICATE_CONFLICT,\n              message: `Column '${error.columns}' duplicate in '${error.table}' table`,\n              layer: 'DAO'\n            })\n          }\n\n          if (error instanceof NotNullViolationError) {\n            throw new AppError({\n              ...errorCodes.DB_NOTNULL_CONFLICT,\n              message: `Not null conflict failed for table '${error.table}' and column '${error.column}'`,\n              layer: 'DAO'\n            })\n          }\n\n          throw new AppError({ ...errorCodes.DB, message: error.message, layer: 'DAO' })\n        })\n    })\n  }\n\n  /**\n   * ------------------------------\n   * @HOOKS\n   * ------------------------------\n   */\n\n  $beforeUpdate () {\n    this.updatedAt = new Date().toISOString()\n  }\n\n  /**\n   * ------------------------------\n   * @METHODS\n   * ------------------------------\n   */\n\n  static async baseCreate (data = {}) {\n    assert.object(data, { required: true })\n    this.verifyUserId(data)\n\n    const result = await this.query().insert(data)\n\n    return this.mapObject(result)\n  }\n\n  static async baseUpdate (id, data = {}) {\n    assert.id(id, { required: true })\n    assert.object(data, { required: true })\n\n    const result = await this.query().patchAndFetchById(id, data)\n\n    return this.mapObject(result)\n  }\n\n  static async baseGetList ({ page, limit, filter, orderBy } = {}) {\n    assert.integer(page, { required: true })\n    assert.integer(limit, { required: true })\n    assert.object(filter, { required: true })\n    assert.id(filter.userId)\n\n    const data = await this.query()\n      .where({ ...filter })\n      .orderBy(orderBy.field, orderBy.direction)\n      .page(page, limit)\n\n    if (!data.results.length) return this.emptyPageResponse()\n    return this.mapPage(data)\n  }\n\n  static async baseGetCount (filter = {}) {\n    assert.object(filter, { required: true })\n\n    const result = await this.query()\n      .where({ ...filter })\n      .count('*')\n      .first()\n    if (!result.count) return 0\n    return Number(result.count)\n  }\n\n  static async baseGetById (id) {\n    assert.id(id, { required: true })\n\n    const data = await this.query().findById(id)\n    if (!data) throw this.errorEmptyResponse()\n\n    return this.mapObject(data)\n  }\n\n  static baseRemove (id) {\n    assert.id(id, { required: true })\n\n    return this.query().deleteById(id)\n  }\n\n  static baseRemoveWhere (where = {}) {\n    assert.object(where, { required: true })\n\n    return this.query().delete().where({ ...where })\n  }\n}\n\nmodule.exports = { BaseDAO }\n\n\nconst { RequestRule } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { emailAgent } = require('../../RootProvider')\nconst { UserDAO } = require('../../../dao/UserDAO')\nconst { UserModel } = require('../../../models/UserModel')\nconst { WelcomeEmail } = require('../common/emails/WelcomeEmail')\nconst { makeEmailConfirmToken } = require('../common/makeEmailConfirmToken')\nconst { makePasswordHash } = require('../common/makePasswordHash')\nconst logger = require('../../../logger')\n\nclass CreateUserAction extends BaseAction {\n  static get accessTag () {\n    return 'users:create'\n  }\n\n  static get validationRules () {\n    return {\n      body: {\n        name: new RequestRule(UserModel.schema.name, { required: true }),\n        username: new RequestRule(UserModel.schema.username, { required: true }),\n        email: new RequestRule(UserModel.schema.email, { required: true }),\n        location: new RequestRule(UserModel.schema.location),\n        password: new RequestRule(UserModel.schema.passwordHash, { required: true })\n      }\n    }\n  }\n\n  static async run (ctx) {\n    const hash = await makePasswordHash(ctx.body.password)\n    delete ctx.body.password\n    const user = await UserDAO.create({\n      ...ctx.body,\n      passwordHash: hash\n    })\n\n    const emailConfirmToken = await makeEmailConfirmToken(user)\n    await UserDAO.baseUpdate(user.id, { emailConfirmToken })\n\n    try {\n      const result = await emailAgent.send(new WelcomeEmail({\n        to: user.email,\n        username: user.username,\n        emailConfirmToken\n      }))\n      logger.info('Registration email, delivered', { to: user.email, ...result, ctx: this.name })\n    } catch (error) {\n      if (error.statusCode) { // log mailGun errors\n        logger.error(error.message, error, { ctx: this.name })\n      } else {\n        throw error\n      }\n    }\n\n    return this.result({ data: user })\n  }\n}\n\nmodule.exports = { CreateUserAction }\n\n\nconst { RequestRule } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { UserDAO } = require('../../../dao/UserDAO')\nconst { UserModel } = require('../../../models/UserModel')\n\nclass UpdateUserAction extends BaseAction {\n  static get accessTag () {\n    return 'users:update'\n  }\n\n  static get validationRules () {\n    return {\n      body: {\n        name: new RequestRule(UserModel.schema.name),\n        location: new RequestRule(UserModel.schema.location)\n      }\n    }\n  }\n\n  static async run (ctx) {\n    const { currentUser } = ctx\n    const data = await UserDAO.baseUpdate(currentUser.id, ctx.body) // user can update only itself\n\n    return this.result({ data })\n  }\n}\n\nmodule.exports = { UpdateUserAction }\n\n\nconst { RequestRule } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { UserDAO } = require('../../../dao/UserDAO')\nconst { UserModel } = require('../../../models/UserModel')\nconst { updateUserPolicy } = require('../../../policy')\n\nclass RemoveUserAction extends BaseAction {\n  static get accessTag () {\n    return 'users:remove'\n  }\n\n  static get validationRules () {\n    return {\n      params: {\n        id: new RequestRule(UserModel.schema.id, { required: true })\n      }\n    }\n  }\n\n  static async run (req) {\n    const { currentUser } = req\n    const id = req.params.id\n\n    const model = await UserDAO.baseGetById(id)\n    await updateUserPolicy(model, currentUser)\n    await UserDAO.baseRemove(id)\n\n    return this.result({ message: `${id} was removed` })\n  }\n}\n\nmodule.exports = { RemoveUserAction }\n\n\nconst { RequestRule } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { UserDAO } = require('../../../dao/UserDAO')\nconst { UserModel } = require('../../../models/UserModel')\nconst { RefreshSessionDAO } = require('../../../dao/RefreshSessionDAO')\nconst { makePasswordHash } = require('../common/makePasswordHash')\nconst { checkPassword } = require('../../../rootcommmon/checkPassword')\n\nclass ChangePasswordAction extends BaseAction {\n  static get accessTag () {\n    return 'users:change-password'\n  }\n\n  static get validationRules () {\n    return {\n      body: {\n        oldPassword: new RequestRule(UserModel.schema.passwordHash, { required: true }),\n        newPassword: new RequestRule(UserModel.schema.passwordHash, { required: true })\n      }\n    }\n  }\n\n  static async run (ctx) {\n    const { currentUser } = ctx\n\n    const userModel = await UserDAO.baseGetById(currentUser.id)\n    await checkPassword(ctx.body.oldPassword, userModel.passwordHash)\n    const newHash = await makePasswordHash(ctx.body.newPassword)\n\n    await Promise.all([\n      RefreshSessionDAO.baseRemoveWhere({ userId: currentUser.id }), // Changing password will remove all logged in refresh sessions\n      UserDAO.baseUpdate(currentUser.id, { passwordHash: newHash })\n    ])\n\n    return this.result({ message: 'Password changed' })\n  }\n}\n\nmodule.exports = { ChangePasswordAction }\n\n\nconst { RequestRule } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { emailAgent } = require('../../RootProvider')\nconst { UserDAO } = require('../../../dao/UserDAO')\nconst { UserModel } = require('../../../models/UserModel')\nconst { makeResetPasswordToken } = require('../common/makeResetPasswordToken')\nconst { ResetPasswordEmail } = require('../common/emails/ResetPasswordEmail')\n\n/**\n * 1) get email from body request\n * 2) find user in DB by email\n * 3) generate and store resetPasswordToken to DB\n * 4) send reset email\n */\nclass SendResetPasswordEmailAction extends BaseAction {\n  static get accessTag () {\n    return 'users:send-reset-password-email'\n  }\n\n  static get validationRules () {\n    return {\n      body: {\n        email: new RequestRule(UserModel.schema.email, { required: true })\n      }\n    }\n  }\n\n  static async run (ctx) {\n    const user = await UserDAO.getByEmail(ctx.body.email)\n    const resetPasswordToken = await makeResetPasswordToken(user)\n    await UserDAO.baseUpdate(user.id, { resetPasswordToken })\n\n    await emailAgent.send(new ResetPasswordEmail({ to: user.email, resetPasswordToken }))\n\n    return this.result({ message: 'Reset password email delivered' })\n  }\n}\n\nmodule.exports = { SendResetPasswordEmailAction }\n\n\nconst { errorCodes, AppError, RequestRule } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { makePasswordHash } = require('../common/makePasswordHash')\nconst { jwtVerify } = require('../../../rootcommmon/jwt')\nconst { UserDAO } = require('../../../dao/UserDAO')\nconst { UserModel } = require('../../../models/UserModel')\nconst { RefreshSessionDAO } = require('../../../dao/RefreshSessionDAO')\nconst config = require('../../../config')\n\n/**\n * 1) verify resetPasswordToken\n * 2) compare existing resetPasswordToken from DB and resetPasswordToken from request\n * 3) make hash from new password\n * 4) update user entity in DB with new hash, reset resetPasswordToken and refreshTokensMap\n */\nclass ResetPasswordAction extends BaseAction {\n  static get accessTag () {\n    return 'users:reset-password'\n  }\n\n  static get validationRules () {\n    return {\n      body: {\n        resetPasswordToken: new RequestRule(UserModel.schema.resetPasswordToken, { required: true }),\n        password: new RequestRule(UserModel.schema.passwordHash, { required: true })\n      }\n    }\n  }\n\n  static async run (ctx) {\n    const tokenData = await jwtVerify(ctx.body.resetPasswordToken, config.token.resetPassword.secret)\n    const tokenUserId = tokenData.sub\n    const user = await UserDAO.baseGetById(tokenUserId)\n\n    if (user.resetPasswordToken !== ctx.body.resetPasswordToken) {\n      throw new AppError({ ...errorCodes.WRONG_RESET_PASSWORD_TOKEN })\n    }\n    const passwordHash = await makePasswordHash(ctx.body.password)\n\n    await Promise.all([\n      UserDAO.baseUpdate(tokenUserId, { passwordHash, resetPasswordToken: '' }),\n      RefreshSessionDAO.baseRemoveWhere({ userId: tokenUserId })\n    ])\n\n    return this.result({ message: 'Reset password process was successfully applied' })\n  }\n}\n\nmodule.exports = { ResetPasswordAction }\n\n\nconst { RequestRule, errorCodes, AppError } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { UserModel } = require('../../../models/UserModel')\nconst { UserDAO } = require('../../../dao/UserDAO')\nconst { jwtVerify } = require('../../../rootcommmon/jwt')\nconst config = require('../../../config')\nconst logger = require('../../../logger')\n\nclass ConfirmRegistrationAction extends BaseAction {\n  static get accessTag () {\n    return 'users:confirm-registration'\n  }\n\n  static get validationRules () {\n    return {\n      body: {\n        emailConfirmToken: new RequestRule(UserModel.schema.emailConfirmToken, { required: true })\n      }\n    }\n  }\n\n  static async run (ctx) {\n    const tokenData = await jwtVerify(ctx.body.emailConfirmToken, config.token.emailConfirm.secret)\n    const { sub: userId } = tokenData\n\n    const user = await UserDAO.baseGetById(userId)\n    if (user.emailConfirmToken !== ctx.body.emailConfirmToken) {\n      throw new AppError({ ...errorCodes.WRONG_EMAIL_CONFIRM_TOKEN })\n    }\n\n    await UserDAO.baseUpdate(userId, { isConfirmedRegistration: true, emailConfirmToken: null })\n    logger.info('User registration is confirmed', { userId, ctx: this.name })\n\n    return this.result({ message: `User ${userId} registration is confirmed` })\n  }\n}\n\nmodule.exports = { ConfirmRegistrationAction }\n\n\nconst { errorCodes, AppError, RequestRule } = require('supra-core')\n\nconst { ChangeEmail } = require('../common/emails/ChangeEmail')\nconst { makeEmailConfirmToken } = require('../common/makeEmailConfirmToken')\nconst { emailAgent } = require('../../RootProvider')\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { UserDAO } = require('../../../dao/UserDAO')\nconst { UserModel } = require('../../../models/UserModel')\n\nclass ChangeEmailAction extends BaseAction {\n  static get accessTag () {\n    return 'users:change-email'\n  }\n\n  static get validationRules () {\n    return {\n      body: {\n        newEmail: new RequestRule(UserModel.schema.email, { required: true })\n      }\n    }\n  }\n\n  static async run (ctx) {\n    const { currentUser } = ctx\n    const { newEmail } = ctx.body\n\n    const isExist = await UserDAO.isEmailExist(newEmail)\n    if (isExist) throw new AppError({ ...errorCodes.EMAIL_ALREADY_TAKEN })\n\n    const emailConfirmToken = await makeEmailConfirmToken({ ...currentUser, newEmail })\n    await emailAgent.send(new ChangeEmail({ newEmail, emailConfirmToken }))\n    await UserDAO.baseUpdate(currentUser.id, { newEmail, emailConfirmToken })\n\n    return this.result({ message: `User requested change email to ${newEmail}!` })\n  }\n}\n\nmodule.exports = { ChangeEmailAction }\n\n\nconst { errorCodes, AppError, RequestRule } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { UserDAO } = require('../../../dao/UserDAO')\nconst { UserModel } = require('../../../models/UserModel')\nconst { jwtVerify } = require('../../../rootcommmon/jwt')\nconst config = require('../../../config')\nconst logger = require('../../../logger')\n\nclass ConfirmEmailAction extends BaseAction {\n  static get accessTag () {\n    return 'users:confirm-email'\n  }\n\n  static get validationRules () {\n    return {\n      body: {\n        emailConfirmToken: new RequestRule(UserModel.schema.emailConfirmToken, { required: true })\n      }\n    }\n  }\n\n  static async run (ctx) {\n    const tokenData = await jwtVerify(ctx.body.emailConfirmToken, config.token.emailConfirm.secret)\n    const { sub: userId } = tokenData\n\n    const user = await UserDAO.baseGetById(userId)\n    const newEmail = user.newEmail\n    if (user.emailConfirmToken !== ctx.body.emailConfirmToken) {\n      throw new AppError({ ...errorCodes.WRONG_EMAIL_CONFIRM_TOKEN })\n    }\n    await UserDAO.baseUpdate(userId, {\n      email: newEmail,\n      newEmail: null,\n      emailConfirmToken: null\n    })\n    logger.info('User email confirmed', { userId, newEmail, ctx: this.name })\n\n    return this.result({ message: `${newEmail} confirmed` })\n  }\n}\n\nmodule.exports = { ConfirmEmailAction }\n\n\nconst { AppError, errorCodes } = require('supra-core')\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { emailAgent } = require('../../RootProvider')\nconst { UserDAO } = require('../../../dao/UserDAO')\nconst { makeEmailConfirmToken } = require('../common/makeEmailConfirmToken')\nconst { ChangeEmail } = require('../common/emails/ChangeEmail')\n\nclass ResendConfirmNewEmailTokenAction extends BaseAction {\n  static get accessTag () {\n    return 'users:resend-confirm-new-email-token'\n  }\n\n  static async run (ctx) {\n    const { currentUser } = ctx\n\n    const user = await UserDAO.baseGetById(currentUser.id)\n    if (!user.newEmail) {\n      throw new AppError({ ...errorCodes.NOT_FOUND, message: 'There is no new email confirmation.' })\n    }\n    const { newEmail } = user\n\n    const emailConfirmToken = await makeEmailConfirmToken(user)\n    await emailAgent.send(new ChangeEmail({ newEmail, emailConfirmToken }))\n    await UserDAO.baseUpdate(currentUser.id, { emailConfirmToken })\n\n    return this.result({ message: 'Email confirmation token was send!' })\n  }\n}\n\nmodule.exports = { ResendConfirmNewEmailTokenAction }\n\n\nconst { BaseAction } = require('../../../rootcommmon/BaseAction')\nconst { UserDAO } = require('../../../dao/UserDAO')\n\nclass CancelEmailChangingAction extends BaseAction {\n  static get accessTag () {\n    return 'users:cancel-email-changing'\n  }\n\n  static async run (ctx) {\n    const { currentUser } = ctx\n    await UserDAO.baseUpdate(currentUser.id, {\n      newEmail: null,\n      emailConfirmToken: null\n    })\n\n    return this.result({ message: 'Email changing canceled!' })\n  }\n}\n\nmodule.exports = { CancelEmailChangingAction }\n",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"supra-api-nodejs-api-doc\",\n        \"version\": \"1.0.0\",\n        \"description\": \"\",\n        \"termsOfService\": \"https://github.com/zmts/supra-api-nodejs/blob/master/LICENSE\",\n        \"contact\": {\n            \"name\": \"Sasha Zmts\",\n            \"email\": \"example@gmail.com\",\n            \"url\": \"https://github.com/zmts\"\n        },\n        \"license\": {\n            \"name\": \"MIT\",\n            \"url\": \" https://github.com/zmts/supra-api-nodejs/blob/master/LICENSE\"\n        }\n    },\n    \"servers\": [\n        {\n            \"url\": \"https://localhost:5000\",\n            \"description\": \"development server\"\n        }\n    ],\n    \"paths\": {\n        \"/auth/login\": {\n            \"post\": {\n                \"summary\": \"Auth login\",\n                \"tags\": [\"Auth\"],\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/AuthLoginRequest\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful login\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/AuthLoginResponse\"\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        \"/auth/logout\": {\n            \"post\": {\n                \"summary\": \"Auth logout\",\n                \"tags\": [\"Auth\"],\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/AuthLogoutRequest\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"User logged out successfully\"\n                    }\n                }\n            }\n        },\n        \"/auth/refresh-tokens\": {\n            \"post\": {\n                \"summary\": \"Refresh tokens\",\n                \"tags\": [\"Auth\"],\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/RefreshTokensRequest\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Tokens refreshed successfully\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/RefreshTokensResponse\"\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        \"/posts\": {\n            \"get\": {\n                \"summary\": \"List posts\",\n                \"tags\": [\"Posts\"],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"List of posts\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/PostsListResponse\"\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            \"post\": {\n                \"summary\": \"Create post\",\n                \"tags\": [\"Posts\"],\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/CreatePostRequest\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Post created successfully\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/CreatePostResponse\"\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        \"/posts/{id}\": {\n            \"get\": {\n                \"summary\": \"Get post by ID\",\n                \"tags\": [\"Posts\"],\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Post details retrieved\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/PostDetailsResponse\"\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            \"patch\": {\n                \"summary\": \"Update post\",\n                \"tags\": [\"Posts\"],\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                ],\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/UpdatePostRequest\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Post updated successfully\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/UpdatePostResponse\"\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            \"delete\": {\n                \"summary\": \"Remove post\",\n                \"tags\": [\"Posts\"],\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Post removed successfully\"\n                    }\n                }\n            }\n        },\n        \"/users\": {\n            \"get\": {\n                \"summary\": \"List users\",\n                \"tags\": [\"Users\"],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"List of users\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/UsersListResponse\"\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            \"post\": {\n                \"summary\": \"Create user\",\n                \"tags\": [\"Users\"],\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/CreateUserRequest\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"User created successfully\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/CreateUserResponse\"\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        \"/users/current\": {\n            \"get\": {\n                \"summary\": \"Get current user\",\n                \"tags\": [\"Users\"],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Current user details\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/CurrentUserResponse\"\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        \"/users/{id}\": {\n            \"get\": {\n                \"summary\": \"Get user by ID\",\n                \"tags\": [\"Users\"],\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"User details retrieved\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/UserDetailsResponse\"\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            \"delete\": {\n                \"summary\": \"Remove user\",\n                \"tags\": [\"Users\"],\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"User removed successfully\"\n                    }\n                }\n            }\n        },\n        \"/users/change-password\": {\n            \"post\": {\n                \"summary\": \"Change password\",\n                \"tags\": [\"Users\"],\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/ChangePasswordRequest\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Password changed successfully\"\n                    }\n                }\n            }\n        },\n        \"/users/send-reset-password-email\": {\n            \"post\": {\n                \"summary\": \"Send reset password email\",\n                \"tags\": [\"Users\"],\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/SendResetPasswordEmailRequest\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Reset password email sent\"\n                    }\n                }\n            }\n        },\n        \"/users/reset-password\": {\n            \"post\": {\n                \"summary\": \"Reset password\",\n                \"tags\": [\"Users\"],\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/ResetPasswordRequest\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Password reset successfully\"\n                    }\n                }\n            }\n        },\n        \"/users/confirm-registration\": {\n            \"post\": {\n                \"summary\": \"Confirm registration\",\n                \"tags\": [\"Users\"],\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/ConfirmRegistrationRequest\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"User registration confirmed\"\n                    }\n                }\n            }\n        },\n        \"/users/change-email\": {\n            \"post\": {\n                \"summary\": \"Change email\",\n                \"tags\": [\"Users\"],\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/ChangeEmailRequest\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Email change requested\"\n                    }\n                }\n            }\n        },\n        \"/users/confirm-email\": {\n            \"post\": {\n                \"summary\": \"Confirm email change\",\n                \"tags\": [\"Users\"],\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/ConfirmEmailRequest\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Email change confirmed\"\n                    }\n                }\n            }\n        },\n        \"/users/resend-confirm-new-email-token\": {\n            \"post\": {\n                \"summary\": \"Resend confirm new email token\",\n                \"tags\": [\"Users\"],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Resent email confirmation token\"\n                    }\n                }\n            }\n        },\n        \"/users/cancel-email-changing\": {\n            \"post\": {\n                \"summary\": \"Cancel email changing\",\n                \"tags\": [\"Users\"],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Email changing canceled\"\n                    }\n                }\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"AuthLoginRequest\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"password\": {\n                        \"type\": \"string\"\n                    },\n                    \"email\": {\n                        \"type\": \"string\"\n                    },\n                    \"fingerprint\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"AuthLoginResponse\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"accessToken\": {\n                        \"type\": \"string\"\n                    },\n                    \"refreshToken\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"AuthLogoutRequest\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"refreshToken\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"RefreshTokensRequest\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"fingerprint\": {\n                        \"type\": \"string\"\n                    },\n                    \"refreshToken\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"RefreshTokensResponse\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"accessToken\": {\n                        \"type\": \"string\"\n                    },\n                    \"refreshToken\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"PostsListResponse\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"object\"\n                }\n            },\n            \"CreatePostRequest\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"title\": {\n                        \"type\": \"string\"\n                    },\n                    \"content\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"CreatePostResponse\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"data\": {\n                        \"type\": \"object\"\n                    }\n                }\n            },\n            \"PostDetailsResponse\": {\n                \"type\": \"object\"\n            },\n            \"UpdatePostRequest\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"title\": {\n                        \"type\": \"string\"\n                    },\n                    \"content\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"UpdatePostResponse\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"data\": {\n                        \"type\": \"object\"\n                    }\n                }\n            },\n            \"UsersListResponse\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"object\"\n                }\n            },\n            \"CreateUserRequest\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"name\": {\n                        \"type\": \"string\"\n                    },\n                    \"username\": {\n                        \"type\": \"string\"\n                    },\n                    \"email\": {\n                        \"type\": \"string\"\n                    },\n                    \"location\": {\n                        \"type\": \"string\"\n                    },\n                    \"password\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"CreateUserResponse\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"data\": {\n                        \"type\": \"object\"\n                    }\n                }\n            },\n            \"CurrentUserResponse\": {\n                \"type\": \"object\"\n            },\n            \"UserDetailsResponse\": {\n                \"type\": \"object\"\n            },\n            \"ChangePasswordRequest\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"oldPassword\": {\n                        \"type\": \"string\"\n                    },\n                    \"newPassword\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"SendResetPasswordEmailRequest\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"email\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"ResetPasswordRequest\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"resetPasswordToken\": {\n                        \"type\": \"string\"\n                    },\n                    \"password\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"ConfirmRegistrationRequest\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"emailConfirmToken\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"ChangeEmailRequest\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"newEmail\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"ConfirmEmailRequest\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"emailConfirmToken\": {\n                        \"type\": \"string\"\n                    }\n                }\n            }\n        }\n    }\n} [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nimport bcrypt from 'bcrypt';\n/*\n\nCopyright (c) 2019 - present AppSeed.us\n\n*/\nimport express from 'express';\nimport Joi from 'joi';\nimport jwt from 'jsonwebtoken';\n\nimport { checkToken } from '../config/safeRoutes';\nimport ActiveSession from '../models/activeSession';\nimport User from '../models/user';\nimport { connection } from '../server/database';\nimport { logoutUser } from '../controllers/logout.controller';\n\n// eslint-disable-next-line new-cap\nconst router = express.Router();\n// Route: <HOST>:PORT/api/users/\n\nconst userSchema = Joi.object().keys({\n  email: Joi.string().email().required(),\n  username: Joi.string().alphanum().min(4).max(15)\n    .optional(),\n  password: Joi.string().required(),\n});\n\nrouter.post('/register', (req, res) => {\n  // Joy Validation\n  const result = userSchema.validate(req.body);\n  if (result.error) {\n    res.status(422).json({\n      success: false,\n      msg: `Validation err: ${result.error.details[0].message}`,\n    });\n    return;\n  }\n\n  const { username, email, password } = req.body;\n\n  const userRepository = connection!.getRepository(User);\n\n  userRepository.findOne({ email }).then((user) => {\n    if (user) {\n      res.json({ success: false, msg: 'Email already exists' });\n    } else {\n      bcrypt.genSalt(10, (_err, salt) => {\n        bcrypt.hash(password, salt).then((hash) => {\n          const query = {\n            username,\n            email,\n            password: hash,\n          };\n\n          userRepository.save(query).then((u) => {\n            res.json({ success: true, userID: u.id, msg: 'The user was successfully registered' });\n          });\n        });\n      });\n    }\n  });\n});\n\nrouter.post('/login', (req, res) => {\n  // Joy Validation\n  const result = userSchema.validate(req.body);\n  if (result.error) {\n    res.status(422).json({\n      success: false,\n      msg: `Validation err: ${result.error.details[0].message}`,\n    });\n    return;\n  }\n\n  const { email } = req.body;\n  const { password } = req.body;\n\n  const userRepository = connection!.getRepository(User);\n  const activeSessionRepository = connection!.getRepository(ActiveSession);\n  userRepository.findOne({ email }).then((user) => {\n    if (!user) {\n      return res.json({ success: false, msg: 'Wrong credentials' });\n    }\n\n    if (!user.password) {\n      return res.json({ success: false, msg: 'No password' });\n    }\n\n    bcrypt.compare(password, user.password, (_err2, isMatch) => {\n      if (isMatch) {\n        if (!process.env.SECRET) {\n          throw new Error('SECRET not provided');\n        }\n\n        const token = jwt.sign({\n          id: user.id,\n          username: user.username,\n          email: user.email,\n        }, process.env.SECRET, {\n          expiresIn: 86400, // 1 week\n        });\n\n        const query = { userId: user.id, token };\n\n        activeSessionRepository.save(query);\n        // Delete the password (hash)\n        (user as { password: string | undefined }).password = undefined;\n        return res.json({\n          success: true,\n          token,\n          user,\n        });\n      }\n      return res.json({ success: false, msg: 'Wrong credentials' });\n    });\n  });\n});\n\nrouter.post('/logout', checkToken, logoutUser);\n\nrouter.post('/checkSession', checkToken, (_req, res) => {\n  res.json({ success: true });\n});\n\nrouter.post('/all', checkToken, (_req, res) => {\n  const userRepository = connection!.getRepository(User);\n\n  userRepository.find({}).then((users) => {\n    users = users.map((item) => {\n      const x = item;\n      (x as { password: string | undefined }).password = undefined;\n      return x;\n    });\n    res.json({ success: true, users });\n  }).catch(() => res.json({ success: false }));\n});\n\nrouter.post('/edit', checkToken, (req, res) => {\n  const { userID, username, email } = req.body;\n\n  const userRepository = connection!.getRepository(User);\n\n  userRepository.find({ id: userID }).then((user) => {\n    if (user.length === 1) {\n      const query = { id: user[0].id };\n      const newvalues = { username, email };\n      userRepository.update(query, newvalues).then(\n        () => {\n          res.json({ success: true });\n        },\n      ).catch(() => {\n        res.json({ success: false, msg: 'There was an error. Please contract the administrator' });\n      });\n    } else {\n      res.json({ success: false, msg: 'Error updating user' });\n    }\n  });\n});\n\n// Used for tests (nothing functional)\nrouter.get('/testme', (_req, res) => {\n  res.status(200).json({ success: true, msg: 'all good' });\n});\n\nexport default router;\n\n\nimport 'dotenv/config';\n\nimport compression from 'compression';\nimport cors from 'cors';\n/*\n\nCopyright (c) 2019 - present AppSeed.us\n\n*/\nimport express from 'express';\nimport passport from 'passport';\n\nimport initPassport from '../config/passport';\nimport routes from '../routes/users';\nimport sessionRoute from '../routes/session.route'\nimport { connect } from './database';\n\n// Instantiate express\nconst server = express();\nserver.use(compression());\n\n// Passport Config\ninitPassport(passport);\nserver.use(passport.initialize());\n\n// Connect to sqlite\nif (process.env.NODE_ENV !== 'test') {\n  connect();\n}\n\nserver.use(cors());\nserver.use(express.json());\n\n// Initialize routes middleware\nserver.use('/api/users', routes);\nserver.use('/api/sessions', sessionRoute)\n\nexport default server;\n\n\nimport express from 'express';\nimport { githubOauthHandler } from '../controllers/auth.controller';\n\nconst router = express.Router();\n\nrouter.get('/oauth/github', githubOauthHandler);\n\nexport default router;\n\nBelow are the implementations:\n\nimport {  Request, Response } from 'express';\nimport {\n    getGithubOathToken,\n    getGithubUser,\n  } from '../services/session.service';\nimport { createUserWithToken } from '../services/user.service';\n\nexport const githubOauthHandler = async (\n    req: Request,\n    res: Response,\n  ) => {\n    try {\n      const code = req.query.code as string;\n  \n      if (!code) {\n        return res.json({error: 'authorization code not provided'})\n      }\n  \n      // Get access_token using code\n      const { access_token } = await getGithubOathToken({ code });\n  \n      // Get user details using access token\n      const userData = await getGithubUser({access_token});\n\n      const returnedUser = await createUserWithToken(userData)\n      \n      res.json({user: returnedUser})\n      \n    } catch (err: any) {\n      res.json({'error': err.message})\n    }\n  };\n  \n\nimport ActiveSession from '../models/activeSession';\nimport { connection } from '../server/database';\n\nexport const logoutUser = (req: any, res: any) => {\n    const { token } = req.body;\n    const activeSessionRepository = connection!.getRepository(ActiveSession);\n  \n    activeSessionRepository.delete({ token })\n      .then(() => res.json({ success: true }))\n      .catch(() => {\n        res.json({ success: false, msg: 'Token revoked' });\n      });\n  }",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n      \"title\": \"api-server-nodejs-api-doc\",\n      \"version\": \"1.0.0\",\n      \"description\": \"Nodejs API Server - Express / SQLite / TypeORM | AppSeed\",\n      \"termsOfService\": \"https://github.com/app-generator/api-server-nodejs/blob/master/README.md\",\n      \"contact\": {\n        \"name\": \"App Generator\",\n        \"email\": \"example@gmail.com\",\n        \"url\": \"https://github.com/app-generator\"\n      },\n      \"license\": {\n        \"name\": \"LICENSE\",\n        \"url\": \"https://github.com/app-generator/api-server-nodejs/blob/master/LICENSE.md\"\n      }\n    },\n    \"servers\": [\n      {\n        \"url\": \"https://localhost:3000\",\n        \"description\": \"development server\"\n      }\n    ],\n    \"paths\": {\n      \"/api/users/register\": {\n        \"post\": {\n          \"summary\": \"Register a new user\",\n          \"description\": \"Creates a new user with the provided email, username, and password. Returns the user ID if successful.\",\n          \"requestBody\": {\n            \"required\": true,\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"email\": {\n                      \"type\": \"string\",\n                      \"format\": \"email\"\n                    },\n                    \"username\": {\n                      \"type\": \"string\",\n                      \"minLength\": 4,\n                      \"maxLength\": 15\n                    },\n                    \"password\": {\n                      \"type\": \"string\"\n                    }\n                  },\n                  \"required\": [\"email\", \"password\"]\n                }\n              }\n            }\n          },\n          \"responses\": {\n            \"200\": {\n              \"description\": \"User successfully registered\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"success\": {\n                        \"type\": \"boolean\"\n                      },\n                      \"userID\": {\n                        \"type\": \"string\"\n                      },\n                      \"msg\": {\n                        \"type\": \"string\"\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            \"422\": {\n              \"description\": \"Validation error\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"success\": {\n                        \"type\": \"boolean\"\n                      },\n                      \"msg\": {\n                        \"type\": \"string\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"/api/users/login\": {\n        \"post\": {\n          \"summary\": \"Login a user\",\n          \"description\": \"Authenticates the user with the provided email and password. Returns a JWT token if successful.\",\n          \"requestBody\": {\n            \"required\": true,\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"email\": {\n                      \"type\": \"string\",\n                      \"format\": \"email\"\n                    },\n                    \"password\": {\n                      \"type\": \"string\"\n                    }\n                  },\n                  \"required\": [\"email\", \"password\"]\n                }\n              }\n            }\n          },\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Login successful\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"success\": {\n                        \"type\": \"boolean\"\n                      },\n                      \"token\": {\n                        \"type\": \"string\"\n                      },\n                      \"user\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                          \"id\": {\n                            \"type\": \"string\"\n                          },\n                          \"username\": {\n                            \"type\": \"string\"\n                          },\n                          \"email\": {\n                            \"type\": \"string\",\n                            \"format\": \"email\"\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            \"401\": {\n              \"description\": \"Authentication failed\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"success\": {\n                        \"type\": \"boolean\"\n                      },\n                      \"msg\": {\n                        \"type\": \"string\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"/api/users/logout\": {\n        \"post\": {\n          \"summary\": \"Logout a user\",\n          \"description\": \"Logs out a user by revoking their active session using the provided token.\",\n          \"requestBody\": {\n            \"required\": true,\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"token\": {\n                      \"type\": \"string\"\n                    }\n                  },\n                  \"required\": [\"token\"]\n                }\n              }\n            }\n          },\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Logout successful\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"success\": {\n                        \"type\": \"boolean\"\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            \"400\": {\n              \"description\": \"Logout failed\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"success\": {\n                        \"type\": \"boolean\"\n                      },\n                      \"msg\": {\n                        \"type\": \"string\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"/api/users/checkSession\": {\n        \"post\": {\n          \"summary\": \"Check user session\",\n          \"description\": \"Checks if the user session is still valid using the provided token.\",\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Session is valid\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"success\": {\n                        \"type\": \"boolean\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"/api/users/all\": {\n        \"post\": {\n          \"summary\": \"Retrieve all users\",\n          \"description\": \"Returns a list of all registered users. Passwords are excluded from the response.\",\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Users retrieved successfully\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"success\": {\n                        \"type\": \"boolean\"\n                      },\n                      \"users\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                          \"type\": \"object\",\n                          \"properties\": {\n                            \"id\": {\n                              \"type\": \"string\"\n                            },\n                            \"username\": {\n                              \"type\": \"string\"\n                            },\n                            \"email\": {\n                              \"type\": \"string\",\n                              \"format\": \"email\"\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            \"500\": {\n              \"description\": \"Failed to retrieve users\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"success\": {\n                        \"type\": \"boolean\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"/api/users/edit\": {\n        \"post\": {\n          \"summary\": \"Edit user information\",\n          \"description\": \"Updates the username and/or email for the specified user ID.\",\n          \"requestBody\": {\n            \"required\": true,\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"userID\": {\n                      \"type\": \"string\"\n                    },\n                    \"username\": {\n                      \"type\": \"string\"\n                    },\n                    \"email\": {\n                      \"type\": \"string\",\n                      \"format\": \"email\"\n                    }\n                  },\n                  \"required\": [\"userID\"]\n                }\n              }\n            }\n          },\n          \"responses\": {\n            \"200\": {\n              \"description\": \"User information updated successfully\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"success\": {\n                        \"type\": \"boolean\"\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            \"400\": {\n              \"description\": \"Failed to update user information\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"success\": {\n                        \"type\": \"boolean\"\n                      },\n                      \"msg\": {\n                        \"type\": \"string\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"/api/users/testme\": {\n        \"get\": {\n          \"summary\": \"Test endpoint\",\n          \"description\": \"A simple test endpoint to verify if the server is running.\",\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Server is running\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"success\": {\n                        \"type\": \"boolean\"\n                      },\n                      \"msg\": {\n                        \"type\": \"string\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"/api/sessions/oauth/github\": {\n        \"get\": {\n          \"summary\": \"GitHub OAuth handler\",\n          \"description\": \"Handles GitHub OAuth authentication and creates a new user if successful.\",\n          \"parameters\": [\n            {\n              \"name\": \"code\",\n              \"in\": \"query\",\n              \"required\": true,\n              \"schema\": {\n                \"type\": \"string\"\n              }\n            }\n          ],\n          \"responses\": {\n            \"200\": {\n              \"description\": \"GitHub OAuth successful\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"user\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                          \"id\": {\n                            \"type\": \"string\"\n                          },\n                          \"username\": {\n                            \"type\": \"string\"\n                          },\n                          \"email\": {\n                            \"type\": \"string\",\n                            \"format\": \"email\"\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            \"400\": {\n              \"description\": \"GitHub OAuth failed\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"error\": {\n                        \"type\": \"string\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nrequire('rootpath')();\nconst express = require('express');\nconst app = express();\nconst cors = require('cors');\nconst jwt = require('_helpers/jwt');\nconst errorHandler = require('_helpers/error-handler');\n\napp.use(express.urlencoded({ extended: false }));\napp.use(express.json());\napp.use(cors());\n\n// use JWT auth to secure the api\napp.use(jwt());\n\n// api routes\napp.use('/users', require('./users/users.controller'));\n\n// global error handler\napp.use(errorHandler);\n\n// start server\nconst port = process.env.NODE_ENV === 'production' ? 80 : 4000;\nconst server = app.listen(port, function () {\n    console.log('Server listening on port ' + port);\n});\n\nBelow are the implementations:\n\nconst express = require('express');\nconst router = express.Router();\nconst userService = require('./user.service');\n\n// routes\nrouter.post('/authenticate', authenticate);\nrouter.get('/', getAll);\n\nmodule.exports = router;\n\nfunction authenticate(req, res, next) {\n    userService.authenticate(req.body)\n        .then(user => res.json(user))\n        .catch(next);\n}\n\nfunction getAll(req, res, next) {\n    userService.getAll()\n        .then(users => res.json(users))\n        .catch(next);\n}\n\n\nconst config = require('config.json');\nconst jwt = require('jsonwebtoken');\n\n// users hardcoded for simplicity, store in a db for production applications\nconst users = [{ id: 1, username: 'test', password: 'test', firstName: 'Test', lastName: 'User' }];\n\nmodule.exports = {\n    authenticate,\n    getAll\n};\n\nasync function authenticate({ username, password }) {\n    const user = users.find(u => u.username === username && u.password === password);\n\n    if (!user) throw 'Username or password is incorrect';\n\n    // create a jwt token that is valid for 7 days\n    const token = jwt.sign({ sub: user.id }, config.secret, { expiresIn: '7d' });\n\n    return {\n        ...omitPassword(user),\n        token\n    };\n}\n\nasync function getAll() {\n    return users.map(u => omitPassword(u));\n}\n\n// helper functions\n\nfunction omitPassword(user) {\n    const { password, ...userWithoutPassword } = user;\n    return userWithoutPassword;\n}",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"node-jwt-authentication-api-api-doc\",\n        \"version\": \"1.0.0\",\n        \"description\": \"NodeJS JWT Authentication API\",\n        \"termsOfService\": \"https://github.com/cornflourblue/node-jwt-authentication-api/blob/master/LICENSE\",\n        \"contact\": {\n            \"name\": \"Jason Watmore\",\n            \"email\": \"example@gmail.com\",\n            \"url\": \"https://github.com/cornflourblue\"\n        },\n        \"license\": {\n            \"name\": \"MIT\",\n            \"url\": \"https://github.com/cornflourblue/node-jwt-authentication-api/blob/master/LICENSE\"\n        }\n    },\n    \"servers\": [\n        {\n            \"url\": \"https://localhost:3000\",\n            \"description\": \"development server\"\n        }\n    ],\n    \"paths\": {\n        \"/users/authenticate\": {\n            \"post\": {\n                \"summary\": \"Authenticate user\",\n                \"description\": \"Endpoint to authenticate a user by providing username and password. Returns a JWT token if authentication is successful.\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"username\": { \"type\": \"string\" },\n                                    \"password\": { \"type\": \"string\" }\n                                },\n                                \"required\": [\"username\", \"password\"]\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful authentication\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"object\",\n                                    \"properties\": {\n                                        \"id\": { \"type\": \"integer\" },\n                                        \"username\": { \"type\": \"string\" },\n                                        \"firstName\": { \"type\": \"string\" },\n                                        \"lastName\": { \"type\": \"string\" },\n                                        \"token\": { \"type\": \"string\" }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"401\": { \"description\": \"Unauthorized - Username or password is incorrect\" }\n                }\n            }\n        },\n        \"/users\": {\n            \"get\": {\n                \"summary\": \"Get all users\",\n                \"description\": \"Endpoint to get all users. Requires a valid JWT token for authorization.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful operation\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"type\": \"object\",\n                                        \"properties\": {\n                                            \"id\": { \"type\": \"integer\" },\n                                            \"username\": { \"type\": \"string\" },\n                                            \"firstName\": { \"type\": \"string\" },\n                                            \"lastName\": { \"type\": \"string\" }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n} [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nimport UsersController from '../controllers/users';\n\nexport default (app) => {\n  const usersController = new UsersController(app.datasource.models.Users);\n  app.route('/users')\n  .all(app.auth.authenticate())\n  .get((req, res) => {\n    usersController.getAll()\n    .then(response => {\n      res.status(response.statusCode);\n      res.json(response.data);\n    });\n  })\n  .post((req, res) => {\n    usersController.create(req.body)\n    .then(response => {\n      res.status(response.statusCode);\n      res.json(response.data);\n    });\n  });\n\n  app.route('/users/:id')\n  .all(app.auth.authenticate())\n  .get((req, res) => {\n    usersController.getById(req.params)\n    .then(response => {\n      res.status(response.statusCode);\n      res.json(response.data);\n    });\n  })\n  .put((req, res) => {\n    usersController.update(req.body, req.params)\n    .then(response => {\n      res.status(response.statusCode);\n      res.json(response.data);\n    });\n  })\n  .delete((req, res) => {\n    usersController.delete(req.params)\n    .then(response => {\n      res.status(response.statusCode);\n      res.json(response.data);\n    });\n  });\n};\n\n\nimport BooksController from '../controllers/books';\n\nexport default (app) => {\n  const booksController = new BooksController(app.datasource.models.Books);\n  app.route('/books')\n    .all(app.auth.authenticate())\n    .get((req, res) => {\n      booksController.getAll()\n        .then(response => {\n          res.status(response.statusCode);\n          res.json(response.data);\n        });\n    })\n  .post((req, res) => {\n    booksController.create(req.body)\n      .then(response => {\n        res.status(response.statusCode);\n        res.json(response.data);\n      });\n  });\n\n  app.route('/books/:id')\n    .all(app.auth.authenticate())\n    .get((req, res) => {\n      booksController.getById(req.params)\n        .then(response => {\n          res.status(response.statusCode);\n          res.json(response.data);\n        });\n    })\n  .put((req, res) => {\n    booksController.update(req.body, req.params)\n      .then(response => {\n        res.status(response.statusCode);\n        res.json(response.data);\n      });\n  })\n  .delete((req, res) => {\n    booksController.delete(req.params)\n      .then(response => {\n        res.status(response.statusCode);\n        res.json(response.data);\n      });\n  });\n};\n\n\nimport HttpStatus from 'http-status';\nimport jwt from 'jwt-simple';\n\nexport default app => {\n  const config = app.config;\n  const Users = app.datasource.models.Users;\n\n  app.post('/token', (req, res) => {\n    if (req.body.email && req.body.password) {\n      const email = req.body.email;\n      const password = req.body.password;\n      console.log(Users);\n      Users.findOne({ where: { email } })\n      .then(user => {\n        console.log(user.password);\n        if (Users.isPassword(user.password, password)) {\n          const payload = { id: user.id };\n          res.json({\n            token: jwt.encode(payload, config.jwtSecret),\n          });\n        } else {\n          res.sendStatus(HttpStatus.UNAUTHORIZED);\n        }\n      })\n      .catch(() => res.sendStatus(HttpStatus.UNAUTHORIZED));\n    } else {\n      res.sendStatus(HttpStatus.UNAUTHORIZED);\n    }\n  });\n};\n\n\nBelow are the implementations:\n\nimport HttpStatus from 'http-status';\n\nconst defaultResponse = (data, statusCode = HttpStatus.OK) => ({\n  data,\n  statusCode,\n});\n\nconst errorResponse = (message, statusCode = HttpStatus.BAD_REQUEST) => defaultResponse({\n  error: message,\n}, statusCode);\n\nclass BooksController {\n  constructor(Books) {\n    this.Books = Books;\n  }\n\n  getAll() {\n    return this.Books.findAll({})\n      .then(result => defaultResponse(result))\n      .catch(error => errorResponse(error.message));\n  }\n\n  getById(params) {\n    return this.Books.findOne({\n      where: params,\n    })\n    .then(result => defaultResponse(result))\n    .catch(error => errorResponse(error.message));\n  }\n\n  create(data) {\n    return this.Books.create(data)\n      .then(result => defaultResponse(result, HttpStatus.CREATED))\n      .catch(error => errorResponse(error.message, HttpStatus.UNPROCESSABLE_ENTITY));\n  }\n\n  update(data, params) {\n    return this.Books.update(data, {\n      where: params,\n    })\n    .then(result => defaultResponse(result))\n    .catch(error => errorResponse(error.message, HttpStatus.UNPROCESSABLE_ENTITY));\n  }\n\n  delete(params) {\n    return this.Books.destroy({\n      where: params,\n    })\n    .then(result => defaultResponse(result, HttpStatus.NO_CONTENT))\n    .catch(error => errorResponse(error.message, HttpStatus.UNPROCESSABLE_ENTITY));\n  }\n}\n\nexport default BooksController;\n\n\nimport HttpStatus from 'http-status';\n\nconst defaultResponse = (data, statusCode = HttpStatus.OK) => ({\n  data,\n  statusCode,\n});\n\nconst errorResponse = (message, statusCode = HttpStatus.BAD_REQUEST) => defaultResponse({\n  error: message,\n}, statusCode);\n\nclass UsersController {\n  constructor(Users) {\n    this.Users = Users;\n  }\n\n  getAll() {\n    return this.Users.findAll({})\n    .then(result => defaultResponse(result))\n    .catch(error => errorResponse(error.message));\n  }\n\n  getById(params) {\n    return this.Users.findOne({\n      where: params,\n    })\n    .then(result => defaultResponse(result))\n    .catch(error => errorResponse(error.message));\n  }\n\n  create(data) {\n    return this.Users.create(data)\n    .then(result => defaultResponse(result, HttpStatus.CREATED))\n    .catch(error => errorResponse(error.message, HttpStatus.UNPROCESSABLE_ENTITY));\n  }\n\n  update(data, params) {\n    return this.Users.update(data, {\n      where: params,\n    })\n    .then(result => defaultResponse(result))\n    .catch(error => errorResponse(error.message, HttpStatus.UNPROCESSABLE_ENTITY));\n  }\n\n  delete(params) {\n    return this.Users.destroy({\n      where: params,\n    })\n    .then(result => defaultResponse(result, HttpStatus.NO_CONTENT))\n    .catch(error => errorResponse(error.message, HttpStatus.UNPROCESSABLE_ENTITY));\n  }\n}\n\nexport default UsersController;\n\n\nexport default (sequelize, DataType) => {\n  const Books = sequelize.define('Books', {\n    id: {\n      type: DataType.INTEGER,\n      primaryKey: true,\n      autoIncrement: true,\n    },\n    name: {\n      type: DataType.STRING,\n      allowNull: false,\n      validate: {\n        notEmpty: true,\n      },\n    },\n  });\n  return Books;\n};\n\n\nimport bcrypt from 'bcrypt';\n\nexport default (sequelize, DataType) => {\n  const Users = sequelize.define('Users', {\n    id: {\n      type: DataType.INTEGER,\n      primaryKey: true,\n      autoIncrement: true,\n    },\n    name: {\n      type: DataType.STRING,\n      allowNull: false,\n      validate: {\n        notEmpty: true,\n      },\n    },\n    email: {\n      type: DataType.STRING,\n      allowNull: false,\n      validate: {\n        notEmpty: true,\n      },\n    },\n    password: {\n      type: DataType.STRING,\n      allowNull: false,\n      validate: {\n        notEmpty: true,\n      },\n    },\n\n  },\n    {\n      hooks: {\n        beforeCreate: user => {\n          const salt = bcrypt.genSaltSync();\n          user.set('password', bcrypt.hashSync(user.password, salt));\n        },\n      },\n      classMethods: {\n        isPassword: (encodedPassword, password) => bcrypt.compareSync(password, encodedPassword),\n      },\n    });\n  return Users;\n};",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"testable-nodejs-api-api-doc\",\n        \"version\": \"1.0.0\",\n        \"description\": \"CÃ³digo da sÃ©rie Node.js API testÃ¡vel disponÃ­vel no meu canal no youtube\",\n        \"contact\": {\n            \"name\": \"waldemarnt\",\n            \"email\": \"example@gmail.com\",\n            \"url\": \"https://github.com/waldemarnt\"\n        },\n        \"termsOfService\": \"\",\n        \"license\": {\n            \"name\": \"ISC\",\n            \"url\": \"https://github.com/waldemarnt/testable-nodejs-api/blob/master/README.md\"\n        }\n    },\n    \"servers\": [\n        {\n            \"url\": \"https://localhost:3000\",\n            \"description\": \"development server\"\n        }\n    ],\n    \"paths\": {\n        \"/users\": {\n            \"get\": {\n                \"summary\": \"Get all users\",\n                \"description\": \"Retrieve a list of all users.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful response with the list of users.\"\n                    }\n                }\n            },\n            \"post\": {\n                \"summary\": \"Create a user\",\n                \"description\": \"Create a new user.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful creation of the user.\"\n                    }\n                }\n            }\n        },\n        \"/users/{id}\": {\n            \"get\": {\n                \"summary\": \"Get user by ID\",\n                \"description\": \"Retrieve a user by their ID.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful response with the user details.\"\n                    }\n                }\n            },\n            \"put\": {\n                \"summary\": \"Update user details\",\n                \"description\": \"Update user details based on the given ID.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful update of user details.\"\n                    }\n                }\n            },\n            \"delete\": {\n                \"summary\": \"Delete user\",\n                \"description\": \"Delete a user based on the given ID.\",\n                \"responses\": {\n                    \"204\": {\n                        \"description\": \"Successful deletion of the user.\"\n                    }\n                }\n            }\n        },\n        \"/books\": {\n            \"get\": {\n                \"summary\": \"Get all books\",\n                \"description\": \"Retrieve a list of all books.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful response with the list of books.\"\n                    }\n                }\n            },\n            \"post\": {\n                \"summary\": \"Create a book\",\n                \"description\": \"Create a new book.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful creation of the book.\"\n                    }\n                }\n            }\n        },\n        \"/books/{id}\": {\n            \"get\": {\n                \"summary\": \"Get book by ID\",\n                \"description\": \"Retrieve a book by its ID.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful response with the book details.\"\n                    }\n                }\n            },\n            \"put\": {\n                \"summary\": \"Update book details\",\n                \"description\": \"Update book details based on the given ID.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful update of book details.\"\n                    }\n                }\n            },\n            \"delete\": {\n                \"summary\": \"Delete book\",\n                \"description\": \"Delete a book based on the given ID.\",\n                \"responses\": {\n                    \"204\": {\n                        \"description\": \"Successful deletion of the book.\"\n                    }\n                }\n            }\n        },\n        \"/token\": {\n            \"post\": {\n                \"summary\": \"Generate authentication token\",\n                \"description\": \"Generate an authentication token based on user credentials.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful generation of the authentication token.\"\n                    },\n                    \"401\": {\n                        \"description\": \"Unauthorized access due to invalid credentials.\"\n                    }\n                }\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"Book\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"id\": {\n                        \"type\": \"integer\",\n                        \"format\": \"int32\"\n                    },\n                    \"name\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"User\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"id\": {\n                        \"type\": \"integer\",\n                        \"format\": \"int32\"\n                    },\n                    \"name\": {\n                        \"type\": \"string\"\n                    },\n                    \"email\": {\n                        \"type\": \"string\"\n                    },\n                    \"password\": {\n                        \"type\": \"string\"\n                    }\n                }\n            }\n        }\n    }\n} [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nconst express = require('express');\n\nconst router = express.Router();\n\nconst BlogPost = require('../models/blogPost');\n\n\n// Routes\nrouter.get('/', (req, res) => {\n\n    BlogPost.find({  })\n        .then((data) => {\n            console.log('Data: ', data);\n            res.json(data);\n        })\n        .catch((error) => {\n            console.log('error: ', daerrorta);\n        });\n});\n\nrouter.post('/save', (req, res) => {\n    const data = req.body;\n\n    const newBlogPost = new BlogPost(data);\n\n    newBlogPost.save((error) => {\n        if (error) {\n            res.status(500).json({ msg: 'Sorry, internal server errors' });\n            return;\n        }\n        // BlogPost\n        return res.json({\n            msg: 'Your data has been saved!!!!!!'\n        });\n    });\n});\n\n\nrouter.get('/name', (req, res) => {\n    const data =  {\n        username: 'peterson',\n        age: 5\n    };\n    res.json(data);\n});\n\n\nmodule.exports = router;\n\nBelow are the implementations:\n\nconst mongoose = require('mongoose');\n\n// Schema\nconst Schema = mongoose.Schema;\nconst BlogPostSchema = new Schema({\n    title: String,\n    body: String,\n    date: {\n        type: String,\n        default: Date.now()\n    }\n});\n\n// Model\nconst BlogPost = mongoose.model('BlogPost', BlogPostSchema);\n\nmodule.exports =  BlogPost;",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"mernapp_youtube-api-doc\",\n        \"version\": \"1.0.0\",\n        \"description\": \"Build a MERN Stack App from scratch, and deploy it to Heroku\",\n        \"termsOfService\": \"https://github.com/accimeesterlin/mernapp_youtube/blob/master/README.md\",\n        \"contact\": {\n            \"name\": \"accimeesterlin\",\n            \"email\": \"example@gmail.com\",\n            \"url\": \"https://github.com/accimeesterlin\"\n        },\n        \"license\": {\n            \"name\": \"ISC\",\n            \"url\": \"https://github.com/accimeesterlin/mernapp_youtube/blob/master/README.md\"\n        }\n    },\n    \"servers\": [\n        {\n            \"url\": \"https://localhost:3000\",\n            \"description\": \"development server\"\n        }\n    ],\n    \"paths\": {\n        \"/\": {\n            \"get\": {\n                \"summary\": \"Get all blog posts\",\n                \"description\": \"Retrieve all blog posts.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful response\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"type\": \"object\",\n                                        \"properties\": {\n                                            \"title\": { \"type\": \"string\" },\n                                            \"body\": { \"type\": \"string\" },\n                                            \"date\": { \"type\": \"string\" }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        \"/save\": {\n            \"post\": {\n                \"summary\": \"Save a new blog post\",\n                \"description\": \"Save a new blog post.\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/BlogPost\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful response\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"object\",\n                                    \"properties\": {\n                                        \"msg\": { \"type\": \"string\" }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"Internal server error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"object\",\n                                    \"properties\": {\n                                        \"msg\": { \"type\": \"string\" }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        \"/name\": {\n            \"get\": {\n                \"summary\": \"Get user data\",\n                \"description\": \"Get hardcoded user data.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful response\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"object\",\n                                    \"properties\": {\n                                        \"username\": { \"type\": \"string\" },\n                                        \"age\": { \"type\": \"number\" }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"BlogPost\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"title\": { \"type\": \"string\" },\n                    \"body\": { \"type\": \"string\" },\n                    \"date\": { \"type\": \"string\" }\n                }\n            }\n        }\n    }\n} [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nimport express from 'express'\nimport User from '../models/User.js'\nimport bcrypt from 'bcrypt'\nimport path from 'path'\nimport multer from 'multer'\n\nconst router = express.Router()\n\nconst storage = multer.diskStorage({\n    destination: function (req, file, cb) {\n        cb(null, 'images');\n    },\n    filename: function (req, file, cb) {\n        cb(null, Date.now() + path.extname(file.originalname));\n    }\n});\n\nconst fileFilter = (req, file, cb) => {\n    const allowedFileTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'];\n    if (allowedFileTypes.includes(file.mimetype)) {\n        cb(null, true);\n    } else {\n        cb(null, false);\n    }\n}\n\nlet upload = multer({ storage, fileFilter });\n\n\n\n/* User Registration */\nrouter.post(\"/signup\", upload.single(\"photo\"), async (req, res) => {\n    try {\n        /* Salting and Hashing the Password */\n        const salt = await bcrypt.genSalt(10);\n        const hashedPass = await bcrypt.hash(req.body.password, salt)\n\n        if (req.file) {\n            /* Create a new user */\n            const newuser = await new User({\n                username: req.body.username,\n                email: req.body.email,\n                password: hashedPass,\n                photo: req.file.filename\n            });\n\n            /* Save User and Return */\n            const user = await newuser.save()\n            res.status(200).json(user)\n        }\n        else {\n            /* Create a new user */\n            const newuser = await new User({\n                username: req.body.username,\n                email: req.body.email,\n                password: hashedPass\n            });\n\n            /* Save User and Return */\n            const user = await newuser.save()\n            res.status(200).json(user)\n        }\n    }\n    catch (err) {\n        console.log(err)\n    }\n})\n\n/* User Login */\nrouter.post(\"/signin\", async (req, res) => {\n    try {\n        const user = await User.findOne({\n            email: req.body.email\n        });\n        !user && res.status(404).json(\"User not found\");\n\n        const validPass = await bcrypt.compare(req.body.password, user.password)\n        !validPass && res.status(400).json(\"Wrong Password\")\n\n        res.status(200).json(user)\n\n    } catch (err) {\n        console.log(err)\n    }\n})\n\nexport default router\n\nimport express from 'express'\nimport Chatroom from '../models/Chatroom.js'\n\nconst router = express.Router()\n\n/* Creating a Chatroom by members userId's */\nrouter.post('/',async (req,res)=>{\n    const newChatroom = new Chatroom({\n        members : [req.body.senderId, req.body.receiverId],\n    });\n    try{\n        const savedChatroom = await newChatroom.save();\n        res.status(200).json(savedChatroom);\n    }\n    catch(err){\n        console.log(err)\n        res.status(500).json(err)\n    }\n})\n\n/* Getting Chatrooms of a Particular user based on UserId*/\nrouter.get('/:userId',async (req,res)=>{\n    try{\n        const chatrooms = await Chatroom.find({\n            members:{$in:[req.params.userId]},\n        })\n        res.status(200).json(chatrooms)\n    }\n    catch(err){\n        console.log(err)\n        res.status(500).json(err)\n    }\n})\n\nexport default router\n\n\nimport express from 'express'\nimport Message from '../models/Message.js'\n\nconst router = express.Router()\n\n/* Posting a Message based on the chatroom id and senderId */\nrouter.post('/',async (req,res)=>{\n    const newMessage = await new Message({\n        chatroomId:req.body.chatroomId,\n        senderId:req.body.senderId,\n        text:req.body.text\n    })\n    try{\n        const savedMessage = await newMessage.save()\n        res.status(200).json(savedMessage)\n    }\n    catch(err){\n        console.log(err)\n        res.status(500).json(err)\n    }\n})\n\n/* Get Messages based on the conversationId */\nrouter.get('/:chatroomId',async(req,res)=>{\n    try{\n        const messages = await Message.find({\n            chatroomId:req.params.chatroomId\n        });\n        res.status(200).json(messages)\n    }\n    catch(err){\n        console.log(err)\n        res.status(500).json(err)\n    }\n})\n\nexport default router\n\n\nimport express from \"express\";\nimport User from \"../models/User.js\";\nimport path from 'path'\nimport multer from 'multer'\n\nconst router = express.Router()\n\nconst storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, 'images');\n  },\n  filename: function (req, file, cb) {\n    cb(null, Date.now() + path.extname(file.originalname));\n  }\n});\n\nconst fileFilter = (req, file, cb) => {\n  const allowedFileTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'];\n  if (allowedFileTypes.includes(file.mimetype)) {\n    cb(null, true);\n  } else {\n    cb(null, false);\n  }\n}\n\nlet upload = multer({ storage, fileFilter });\n\nrouter.put(\"/:id\", upload.single(\"photo\"), async (req, res) => {\n  const username = req.body.username;\n  const updates = {\n    username,\n  };\n  if (req.file) {\n    const photo = req.file.filename;\n    updates.photo = photo;\n  }\n  try {\n    const user = await User.findByIdAndUpdate(req.params.id, {\n      $set: updates,\n    });\n    res.status(200).json(\"Data Updated Succesfully\");\n  } catch (err) {\n    console.log(err)\n    return res.status(500).json(err);\n  }\n});\n\nrouter.delete(\"/:id\", async (req, res) => {\n  if (req.body.userId === req.params.id || req.body.isAdmin) {\n    try {\n      await User.findByIdAndDelete(req.params.id);\n      res.status(200).json(\"Account Deleted Succesfully\");\n    } catch (err) {\n      return res.status(500).json(err);\n    }\n  } else {\n    return res.status(403).send(\"You can Only Update Your Account\");\n  }\n});\n\nrouter.get(\"/:id\", async (req, res) => {\n  try {\n    const user = await User.findById(req.params.id);\n    const { password, updatedAt, ...remaining } =\n      user._doc; /* user._doc => JSON that is resulted */\n    res\n      .status(200)\n      .json(user); /* Removing uneccesary fields for the response JSON */\n  } catch (err) {\n    console.log(err)\n    res.status(500).json(err);\n  }\n});\n\nrouter.get(\"/\", async (req, res) => {\n  try {\n    const user = await User.findOne({ username: req.query.username });\n    res.status(200).json(user);\n  } catch (err) {\n    console.log(err);\n    res.status(500).json(err);\n  }\n});\n\nexport default router;\n\nBelow are the models:\n\nimport mongoose from 'mongoose'\n\nconst ChatroomSchema = new mongoose.Schema({\n    members:{\n        type:Array\n    }\n},\n{timestamps:true}\n);\n\nexport default mongoose.model(\"Chatroom\",ChatroomSchema)\n\nimport mongoose from 'mongoose'\n\nconst MessageSchema = new mongoose.Schema({\n    chatroomId:{\n        type:String\n    },\n    senderId:{\n        type:String\n    },\n    text:{\n        type:String\n    }\n},\n{timestamps:true}\n);\n\nexport default mongoose.model(\"Message\",MessageSchema)\n\nimport mongoose from \"mongoose\";\n\nconst UserSchema = new mongoose.Schema({\n    username: {\n        type: String,\n        require: true,\n        min: 3,\n        max: 15,\n        unique: true\n    },\n    email: {\n        type: String,\n        require: true,\n        max: 50,\n        unique: true\n    },\n    password: {\n        type: String,\n        require: true,\n        min: 6\n    },\n    photo: {\n        type: String,\n        default: \"\"\n    },\n    isAdmin: {\n        type: Boolean,\n        default: false\n    }\n},\n    {\n        timestamps: true\n    });\n\nexport default mongoose.model(\"User\", UserSchema);\n\n",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"AmigoChat API Documentation\",\n        \"version\": \"1.0.0\",\n        \"description\": \"AmigoChat is a real-time chat application allowing users to communicate seamlessly. Built on MERN Stack and Socket io for efficient communication.\",\n        \"termsOfService\": \"https://github.com/iampranavdhar/AmigoChat-Realtime-Chat-Application/blob/master/LICENSE\",\n        \"contact\": {\n            \"name\": \"iampranavdhar\",\n            \"email\": \"example@gmail.com\",\n            \"url\": \"https://github.com/iampranavdhar/\"\n        },\n        \"license\": {\n            \"name\": \"MIT\",\n            \"url\": \"https://github.com/iampranavdhar/AmigoChat-Realtime-Chat-Application/blob/master/LICENSE\"\n        }\n    },\n    \"servers\": [\n        {\n            \"url\": \"https://localhost:3000\",\n            \"description\": \"development server\"\n        }\n    ],\n    \"paths\": {\n        \"/signup\": {\n            \"post\": {\n                \"summary\": \"User Registration\",\n                \"description\": \"This endpoint is to register a new user. It saltes and hashes the password before saving the user details.\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"multipart/form-data\": {\n                            \"schema\": {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"username\": {\n                                        \"type\": \"string\"\n                                    },\n                                    \"email\": {\n                                        \"type\": \"string\"\n                                    },\n                                    \"password\": {\n                                        \"type\": \"string\"\n                                    },\n                                    \"photo\": {\n                                        \"type\": \"string\",\n                                        \"format\": \"binary\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"User successfully created\"\n                    },\n                    \"404\": {\n                        \"description\": \"User not found\"\n                    },\n                    \"400\": {\n                        \"description\": \"Wrong password\"\n                    }\n                }\n            }\n        },\n        \"/signin\": {\n            \"post\": {\n                \"summary\": \"User Login\",\n                \"description\": \"Endpoint for user login. Verifies user credentials and returns user details.\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"email\": {\n                                        \"type\": \"string\"\n                                    },\n                                    \"password\": {\n                                        \"type\": \"string\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"User logged in successfully\"\n                    },\n                    \"404\": {\n                        \"description\": \"User not found\"\n                    },\n                    \"400\": {\n                        \"description\": \"Wrong password\"\n                    }\n                }\n            }\n        },\n        \"/chatroom\": {\n            \"post\": {\n                \"summary\": \"Create Chatroom\",\n                \"description\": \"Endpoint to create a chatroom with specified members.\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"senderId\": {\n                                        \"type\": \"string\"\n                                    },\n                                    \"receiverId\": {\n                                        \"type\": \"string\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Chatroom created successfully\"\n                    },\n                    \"500\": {\n                        \"description\": \"Internal Server Error\"\n                    }\n                }\n            },\n            \"get\": {\n                \"summary\": \"Get User's Chatrooms\",\n                \"description\": \"Endpoint to retrieve chatrooms of a particular user.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"userId\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Chatrooms retrieved successfully\"\n                    },\n                    \"500\": {\n                        \"description\": \"Internal Server Error\"\n                    }\n                }\n            }\n        },\n        \"/message\": {\n            \"post\": {\n                \"summary\": \"Post Message\",\n                \"description\": \"Endpoint to post a message in a chatroom.\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"chatroomId\": {\n                                        \"type\": \"string\"\n                                    },\n                                    \"senderId\": {\n                                        \"type\": \"string\"\n                                    },\n                                    \"text\": {\n                                        \"type\": \"string\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Message posted successfully\"\n                    },\n                    \"500\": {\n                        \"description\": \"Internal Server Error\"\n                    }\n                }\n            },\n            \"get\": {\n                \"summary\": \"Get Messages\",\n                \"description\": \"Endpoint to retrieve messages based on chatroom id.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"chatroomId\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Messages retrieved successfully\"\n                    },\n                    \"500\": {\n                        \"description\": \"Internal Server Error\"\n                    }\n                }\n            }\n        },\n        \"/users/{id}\": {\n            \"put\": {\n                \"summary\": \"Update User\",\n                \"description\": \"Endpoint to update user data including username and photo.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                ],\n                \"requestBody\": {\n                    \"content\": {\n                        \"multipart/form-data\": {\n                            \"schema\": {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"username\": {\n                                        \"type\": \"string\"\n                                    },\n                                    \"photo\": {\n                                        \"type\": \"string\",\n                                        \"format\": \"binary\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"User data updated successfully\"\n                    },\n                    \"500\": {\n                        \"description\": \"Internal Server Error\"\n                    }\n                }\n            },\n            \"delete\": {\n                \"summary\": \"Delete User\",\n                \"description\": \"Endpoint to delete a user account.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"User account deleted successfully\"\n                    },\n                    \"500\": {\n                        \"description\": \"Internal Server Error\"\n                    }\n                }\n            },\n            \"get\": {\n                \"summary\": \"Get User by ID\",\n                \"description\": \"Endpoint to retrieve user details by ID.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"User details retrieved successfully\"\n                    },\n                    \"500\": {\n                        \"description\": \"Internal Server Error\"\n                    }\n                }\n            }\n        },\n        \"/users\": {\n            \"get\": {\n                \"summary\": \"Get User by Username\",\n                \"description\": \"Endpoint to retrieve user details by username.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"username\",\n                        \"in\": \"query\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"User details retrieved successfully\"\n                    },\n                    \"500\": {\n                        \"description\": \"Internal Server Error\"\n                    }\n                }\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"Chatroom\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"members\": {\n                        \"type\": \"array\"\n                    }\n                }\n            },\n            \"Message\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"chatroomId\": {\n                        \"type\": \"string\"\n                    },\n                    \"senderId\": {\n                        \"type\": \"string\"\n                    },\n                    \"text\": {\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"User\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"username\": {\n                        \"type\": \"string\"\n                    },\n                    \"email\": {\n                        \"type\": \"string\"\n                    },\n                    \"password\": {\n                        \"type\": \"string\"\n                    },\n                    \"photo\": {\n                        \"type\": \"string\"\n                    },\n                    \"isAdmin\": {\n                        \"type\": \"boolean\"\n                    }\n                }\n            }\n        }\n    }\n} [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nconst express = require('express');\nconst router = express.Router();\nconst authenticate = require('../middleware/authenticate');\nconst authController = require('../controller/auth');\nconst profileController = require('../controller/profile');\n\nrouter.post('/login', authController.login);\n\n// all routes that come after this middleware are protected\n// and can only be accessed if the user is logged in\nrouter.use(authenticate);\n\nrouter.get('/profile', profileController.profile);\n\nmodule.exports = router;\n\nBelow are the implementations:\n\nconst authService = require('../service/auth');\n\nasync function login(req, res) {\n    const {email, password} = req.body;\n\n    // perform payload validation\n    // in prod, always use a validation library like joi\n    // for this tutorial, we only do basic validation\n    if (!email || !password) {\n        return res.status(400).json('Bad request params - you need to provide an email and a password');\n    }\n\n    try {\n        const user = await authService.login(email, password);\n        req.session.user = user;\n        res.sendStatus(204);\n    } catch(err) {\n        // in prod, do not use console.log or console.error\n        // use a proper logging library like winston\n        console.error(err);\n        res.status(401).json(err);\n    }\n}\n\nmodule.exports = {\n    login\n};\n\nfunction profile(req, res) {\n    res.json(req.session);\n}\n\nmodule.exports = {profile};\n\n",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"express-session-with-redis-api-doc\",\n        \"version\": \"1.0.0\",\n        \"description\": \"A modern Node.js session management API built with Express.js and Redis, allowing users to authenticate and retrieve user profiles.\",\n        \"termsOfService\": \"https://github.com/jangbl/express-session-with-redis/blob/master/README.md\",\n        \"contact\": {\n            \"name\": \"jangbl\",\n            \"email\": \"example@gmail.com\",\n            \"url\": \"https://github.com/jangbl/\"\n        },\n        \"license\": {\n            \"name\": \"ISC\",\n            \"url\": \"https://github.com/jangbl/express-session-with-redis/blob/master/README.md\"\n        }\n    },\n    \"servers\": [\n        {\n            \"url\": \"https://localhost:3000\",\n            \"description\": \"Development server\"\n        }\n    ],\n    \"paths\": {\n        \"/login\": {\n            \"post\": {\n                \"summary\": \"Login user\",\n                \"description\": \"Endpoint to authenticate a user and create a session if credentials are valid. Requires email and password in request body.\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"email\": {\n                                        \"type\": \"string\"\n                                    },\n                                    \"password\": {\n                                        \"type\": \"string\"\n                                    }\n                                },\n                                \"required\": [\"email\", \"password\"]\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"204\": {\n                        \"description\": \"Successful login\"\n                    },\n                    \"400\": {\n                        \"description\": \"Bad request params - you need to provide an email and a password\"\n                    },\n                    \"401\": {\n                        \"description\": \"Unauthorized - Invalid credentials\"\n                    }\n                }\n            }\n        },\n        \"/profile\": {\n            \"get\": {\n                \"summary\": \"Get user profile\",\n                \"description\": \"Retrieve the profile of the logged-in user. Requires valid session authentication.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful operation\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/UserProfile\"\n                                }\n                            }\n                        }\n                    },\n                    \"401\": {\n                        \"description\": \"Unauthorized - User not logged in\"\n                    }\n                }\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"UserProfile\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"id\": {\n                        \"type\": \"string\"\n                    },\n                    \"name\": {\n                        \"type\": \"string\"\n                    },\n                    \"email\": {\n                        \"type\": \"string\"\n                    },\n                    \"createdAt\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\"\n                    }\n                }\n            }\n        }\n    }\n} [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nconst express = require('express');\nconst app = express();\nconst cors = require('cors');\nconst api = require('./api');\n// enabling CORS to accept from all origins\napp.use(cors());\n// express.json() and express.urlencoded() are built-in middleware functions to support JSON-encoded and URL-encoded bodies.\n// to be able to get object data from the url\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// enabling CORS to accept from all origins\napp.all('*', (req, res, next) => {\n  console.log(`${new Date()} - request for ${req.path}`);\n  res.set('Access-Control-Allow-Origin', '*');\n  next();\n});\n\n// the various endpoints\napp.get('/', (req, res) => {\n  res.send('welcome to the bond-api endpoint.');\n});\n\n// calling for implimentation of getting all users\n// ?uid=x to get 1 user\napp.get('/users', api.getAllusers);\n\n// sending bond invite\napp.post('/sendInvite', api.sendInvite);\n\n// persist user data in db to create a new user\napp.post('/user', api.createUser);\n\n// post request to edit user info\napp.post('/editUser',api.editUser);\n\n// post request to bond users \napp.post('/bondUsers',api.bondUsers);\n\n// get bonded users\napp.get('/getBondedUsers/:uid',api.getBondedUsers)\n\n// setting the port of the process or a default port\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`listening on port: ${port}`);\n});\n\nBelow are the implementations:\n\nconst mysql = require('mysql');\nconst nodemailer = require('nodemailer');\nrequire('dotenv').config();\nconst Cryptr = require('cryptr');\nconst formattedHTMLInvite = require('./email/invite');\nconst { v4: uuidv4 } = require('uuid')\n\nconst con = mysql.createConnection({\n  host: process.env.DB_HOST,\n  user: process.env.DB_USER,\n  password: process.env.DB_PASSWORD,\n  database: process.env.DB_DATABASE,\n  port: process.env.DB_PORT,\n});\n\n// endpoint to get all users\nconst getAllusers = async (request, response) => {\n  //initialize return fields incase of error\n  var returnErr = {\n    message: \"Invalid UID\",\n    status: 1\n  };\n  //check wether a query is present\n  if(Object.keys(request.query).length === 0){\n  con.query('SELECT * FROM person', (err, result) => {\n    // handling any errors\n    if (err) throw err;\n    result.map(item => {\n      item.email = item.email.replace(/^(.{2})[^@]+/, \"$1***\");;\n      item.uid = item.uid.replace(/^(.{2})[^@]+/, \"$1***\");;\n    })\n    response.status(200).json(result);\n  });\n}else{\n  //check if query variable name is \"uid\"\n  if(request.query.uid != null){\n    con.query(\"SELECT * FROM person WHERE uid='\"+request.query.uid+\"' LIMIT 1\", function (err, result) {\n      //if invalid uid\n      if(result== undefined || result.length == 0) {\n        response.status(404).json(returnErr)\n        return\n      }\n\n      //if success\n      return response.status(200).json(result);  \n    })\n  }else{\n    //if variable not \"uid\"\n    returnErr.status = 2\n    returnErr.message = \"Could not handle that request\"\n    response.status(500).json(returnErr)\n  }\n  \n}\n};\n\n// endpoint to persist users\nconst createUser = async (request, response) => {\n  const {\n    body: { uid, name, username, photo, email },\n  } = request;\n\n  // pick the user from the database\n  con.query(`SELECT * FROM person WHERE uid=${mysql.escape(uid)}`, (err, result) => {\n    // handling any errors\n    if (err) throw err;\n    // if query returned data then just login user\n    if (result[0]) {\n      console.log('Normal user login => ');\n      response.status(200).json([{ status: 'login', message: `${request.body.name} Logged in successfully!` }]);\n    } else {\n      // if user not in db persist data in the db\n      console.log('Persist user => ');\n      const query = `INSERT INTO person (uid, name, username, email, photo) VALUES ('${uid}', '${name}', '${username}', '${email}', '${photo}')`;\n\n      con.query(query, () => {\n        response\n          .status(200)\n          .json([{ status: 'signup', message: `${request.body.name} account created successfully!` }]);\n      });\n    }\n  });\n};\n\nconst sendInvite = async (request, response) => {\n  const {\n    body: { senderEmail: sender, receiverEmail: receiver },\n  } = request;\n\n  const returnVal = {\n    message: 'Error Posting request',\n    status: 1,\n  };\n\n  if (sender === undefined || receiver === undefined || sender.length === 0 || receiver.length === 0 ||typeof sender === 'object' ||typeof receiver === 'object') {\n    response.status(500).json(returnVal);\n    return;\n  }\n\n\n    con.query(`SELECT * FROM person WHERE email='${sender}' LIMIT 1`, async (__err, senderRes) => {\n      if (senderRes.length === 0) {\n        returnVal.status = 2;\n        returnVal.message = 'Sender email is invalid';\n        response.status(500).json(returnVal);\n        return;\n      }\n\n      // encripting the sender's email to use in the invite\n      const cryptr = new Cryptr('bondkey');\n      const senderEncryptedEmail = cryptr.encrypt(sender);\n\n      const transporter = nodemailer.createTransport({\n        service: 'Gmail',\n        auth: {\n          user: process.env.GMAIL_USER,\n          pass: process.env.GMAIL_PASSWORD,\n        },\n      });\n\n      const info = await transporter.sendMail({\n        from: '\"Bond\" <foo@example.com>',\n        to: receiver,\n        subject: `Bond request from ${senderRes[0].name}`,\n        text: 'Hi there',\n        html: formattedHTMLInvite(senderRes[0], senderEncryptedEmail),\n      });\n\n      // decripting to make sure everything is okay!\n      const senderDecryptedEmail = cryptr.decrypt(senderEncryptedEmail);\n      console.log(`decrypted email => ${senderDecryptedEmail}`);\n      console.log('Message sent: %s', info.messageId);\n      // Message sent: <b658f8ca-6296-ccf4-8306-87d57a0b4321@example.com>\n      response.status(200).json([{ status: 'sent', message: `Bond invite sent successfully to ${receiver}` }]);\n    });\n\n};\n\n// endpoint to edit user info\nconst editUser = async (request, response) => {\n\n  //initialize return object of error\n  var returnErr = {\n    message: \"Invalid Field\",\n    status: 1\n  }\n\n  //initialize person to return to response\n  var personReturn = {\n    uid : request.body.uid,\n    username: request.body.username,\n    photo: request.body.photo\n  }\n\n  //checking all fields for null/garbage values \n  if(typeof request.body.username === 'object' ||typeof request.body.uid === 'object'||typeof request.body.photo === 'object'){\n    return response.status(500).json(returnErr)\n  }\n\n  //not allowing username to have special characters\n  personReturn.username = request.body.username.replace(/[`~!@#$%^&*()|+\\-=?;:'\",.<>\\{\\}\\[\\]\\\\\\//\\s]/gi, '');\n\n  //checking all fields for empty values\n  if(personReturn.username == \"\" ||request.body.photo == \"\" || request.body.uid == \"\"){\n    returnErr.status = 2;\n    returnErr.message = \"Cannot update profile with empty fields\";\n    return response.status(500).json(returnErr)\n  }\n\n\n  //checking to see if username already exists\n  con.query(\"SELECT uid from person WHERE username='\"+personReturn.username+\"'\", function (err, result) {\n\n    if(result.length == 0){\n\n      //updating the person info there is no error\n      con.query(\"UPDATE person SET username='\"+personReturn.username+\"',photo='\"+request.body.photo+\"' WHERE uid='\"+request.body.uid+\"'\", function (err, result) {\n\n        //checking if uid exists and profile was updated successfully\n        if(result.affectedRows == 0 ){\n          returnErr.status = 3;\n          returnErr.message = \"User ID doesnt exist\";\n          return response.status(500).json(returnErr)\n        }\n\n        //if successfull\n        returnErr.status = 0;\n        returnErr.message = \"Profile updated successfully\";\n        response.status(200).json(returnErr)\n        \n      }) //end of update query\n\n    }else{\n      returnErr.status = 4;\n      returnErr.message = \"Username already taken\";\n      response.status(500).json(returnErr)\n    }// end of result.length\n\n  })//end of select query\n\n};\n\nconst compareRoomIds = (roomIds_1,roomIds_2) =>{\n  var flag = false\n\n  if(roomIds_1 == [] || roomIds_2 == []) return flag\n\n  //iterate roomIds of uid_1\n  for(var i = 0 ; i < roomIds_1.length ; i++){\n    //iterate roomIds of uid_2\n    \n    for(var j = 0 ; j < roomIds_2.length ; j++){\n      //if there is an equal then flag = true\n\n      if(roomIds_1[i].room_id == roomIds_2[j].room_id) flag=true\n    }\n  }\n\n  return flag\n}\n\nconst bondUsers =async (request,response) =>{\n\n  // declaring the key for sender's email decryption\n  const cryptr = new Cryptr('bondkey');\n\n  //get variables\n  const senderDecryptedEmail = cryptr.decrypt(request.body.senderEncryptedEmail);  // decrypting the sender's email we got from frontend and will use to bond them\n  const uid_2 = request.body.receiverUid; // the person who accepted the bond invite\n  const roomID = uuidv4();\n  var roomIds_1 = [];\n  var roomIds_2 = [];\n\n  var returnErr = {\n      status : 1,\n      message: \"Could not find user\"\n  }\n  // the email of the sender of the invite mail which is now decryped\n  console.log(senderDecryptedEmail)\n    \n  /**PLEASE NOTE\n   * In the below code uid_1 referes to the uid of sender\n   * and uid_2 referes to the uid of receiver of the invite\n   */\n\n  // get the uid_1(sender's uid) from database using their decrypted email\n  con.query(\"SELECT uid from person WHERE email='\"+senderDecryptedEmail+\"' LIMIT 1\", function (err, result_uid_1_from_email) {\n    uid_1 = result_uid_1_from_email[0].uid; //getting the ui of the sender from their email\n    console.log(result_uid_1_from_email[0].uid);\n  // check if uid_1 exists in database\n  con.query(\"SELECT name,uid from person WHERE uid='\"+uid_1+\"' LIMIT 1\", function (err, result_1) {\n    \n    // check if uid_1 does not exist then return err\n    if(result_1.length == 0 || result_1 == undefined) return response.status(500).json(returnErr)\n\n    // check if uid_2 exists in database\n    con.query(\"SELECT name,uid from person WHERE uid='\"+uid_2+\"' LIMIT 1\", function (err, result_2) {\n      \n      // check if uid_2 does not exist then return err\n      if(result_2.length == 0 || result_1 == undefined) return response.status(500).json(returnErr)\n\n        // get all room_id for uid_1\n        con.query(\"SELECT room_id from bond WHERE person_uid='\"+uid_1+\"'\", function (err, result_roomIds_1) {\n\n          //if not empty then get results otherwise use default = []\n          if(result_roomIds_1.length != 0 ) roomIds_1 = result_roomIds_1\n\n          // get all room_id for uid_2\n          con.query(\"SELECT room_id from bond WHERE person_uid='\"+uid_2+\"'\", function (err, result_roomIds_2) {\n\n          //if not empty then get results otherwise use default = []\n          if(result_roomIds_2.length != 0 ) roomIds_2 = result_roomIds_2\n\n          //compare to see if they have a similar room_id and return status 500 if true\n          if(compareRoomIds(roomIds_1,roomIds_2)){\n            returnErr.status = 3\n            returnErr.message = \"Bond is already created\"\n            response.status(200).json(returnErr)\n            return\n          }\n\n          //set the returnErr to another error type\n          returnErr.status = 2\n          returnErr.message = \"There was a problem executing the request\"\n\n          //start transaction\n          con.beginTransaction((err) =>{\n\n            // Failure transaction\n            if(err){\n              return con.rollback(() => {\n                throw response.status(200).json(returnErr)\n              })\n            }\n            \n            //room name default format\n            var room_name = result_1[0].name +\" & \"+ result_2[0].name \n\n            //insert to room_table before bond_table\n            con.query(\"INSERT INTO room VALUES ('\"+roomID+\"','\"+room_name+\"')\", function (err, result_room) {\n              // Failure transaction\n              if(err){\n                return con.rollback(() => {\n                  throw response.status(500).json(returnErr)\n                })\n              }\n              \n              //insert to bond with uid_1\n              con.query(\"INSERT INTO bond VALUES ('\"+roomID+\"','\"+result_1[0].uid+\"')\", function (err, result_bond_1) {\n                // Failure transaction\n                if(err){\n                  return con.rollback(() => {\n                    throw response.status(500).json(returnErr)\n                  })\n                }\n                \n                  //insert to bond with uid_2\n                con.query(\"INSERT INTO bond VALUES ('\"+roomID+\"','\"+result_2[0].uid+\"')\", function (err, result_bond_2) {\n                  // Failure transaction\n                  \n                  if(err){\n                    return con.rollback(() => {\n                      throw response.status(500).json(returnErr)\n                    })\n                  }else{\n                    con.commit((err)=>{\n                      // Failure transaction\n                      if(err){\n                        return con.rollback(() => {\n                          throw response.status(500).json(returnErr)\n                        })\n                      }\n\n                      //if success\n                      returnErr.status = 0\n                      returnErr.message = \"Bond Success!\"\n                      response.status(200).json(returnErr)\n                    })\n                  }\n                })\n              })\n            })\n          })\n        })\n      })\n    })\n  });\n});\n}\n\nconst getBondedUsers = async(request,response) =>{\n  \n  // initialize variables\n  const targetUid = request.params.uid\n  const roomIds = []\n  const personIds = []\n  const roomAndPerson =[]\n\n  //initialize error return\n  var returnErr = {\n      status : 1,\n      message : \"No bonded users\"\n  }\n\n  //get all room_ids of the target user\n  con.query(\"SELECT room_id FROM bond WHERE person_uid ='\"+targetUid+\"'\",(err , result_roomIds) =>{\n    //if no bonded users\n    if(result_roomIds.length == 0) return response.status(200).json(returnErr)\n\n    //turn result to an array\n    for(var i = 0 ; i < result_roomIds.length ; i++){\n      roomIds.push(\"'\"+result_roomIds[i].room_id+\"'\")\n    }\n    \n    //get all person_uids of all room_ids\n    con.query(\"SELECT person_uid,room.roomname,room.id FROM bond RIGHT JOIN room ON bond.room_id=room.id  WHERE room_id IN (\"+roomIds+\") AND person_uid != '\"+targetUid+\"' \",(err, result_personUids)=>{\n      \n      returnErr.status = 2\n      returnErr.message = \"There was a problem executing the request\"\n\n      //if something wrong with db\n      if(err) return response.status(500).json(returnErr)\n\n      //turn result to array\n      for(i = 0 ; i < result_personUids.length ; i++){\n        //push to string array\n        personIds.push(\"'\"+result_personUids[i].person_uid+\"'\")\n\n        //push to entity relation\n      }\n\n      \n\n      // get all bonded users\n      con.query(\"SELECT * from person WHERE uid IN(\"+personIds+\")\",(err, result_people) => {\n        //if something wrong with db\n        if(err) return response.status(500).json(returnErr)\n\n        //loop result_personUids\n        for(i = 0 ; i < result_personUids.length ; i++){\n          //loop result_people\n          for(j = 0 ; j < result_people.length ; j++){\n            //compare uids to return matched uids\n            if(result_personUids[i].person_uid == result_people[j].uid){\n              \n              //create the object to return\n              var returnObj ={\n                'room_id'   : result_personUids[i].id,\n                'roomname'  : result_personUids[i].roomname,\n                'person'    : result_people[j]\n              }\n              //push to roomAndPerson array\n              roomAndPerson.push(returnObj)\n            }\n          }\n        }\n\n        \n\n        //in success\n        response.status(200).json(roomAndPerson)\n      })\n    })\n  })\n}\n\n//  exporting of all the modules\nmodule.exports = {\n    getAllusers,\n    createUser,\n    sendInvite,\n    editUser,\n    bondUsers,\n    getBondedUsers\n    \n};\n",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n      \"title\": \"Bond API Documentation\",\n      \"version\": \"1.0.0\",\n      \"description\": \"Bond API allows users to send a vibration with a lovely sound to their loved ones, letting them know they are missed, no matter where they are. It provides functionalities to create users, send invites, bond users together, and manage user data.\",\n      \"termsOfService\": \"https://github.com/clevaway/bond/blob/main/LICENSE\",\n      \"contact\": {\n        \"name\": \"fotiecodes\",\n        \"email\": \"example@gmail.com\",\n        \"url\": \"https://github.com/FotieMConstant\"\n      },\n      \"license\": {\n        \"name\": \"MIT\",\n        \"url\": \"https://github.com/clevaway/bond/blob/main/LICENSE\"\n      }\n    },\n    \"servers\": [\n      {\n        \"url\": \"https://localhost:3000\",\n        \"description\": \"Development Server\"\n      }\n    ],\n    \"paths\": {\n      \"/\": {\n        \"get\": {\n          \"summary\": \"Welcome Endpoint\",\n          \"description\": \"This endpoint provides a welcome message for the Bond API.\",\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Welcome message received\",\n              \"content\": {\n                \"text/plain\": {\n                  \"schema\": {\n                    \"type\": \"string\",\n                    \"example\": \"welcome to the bond-api endpoint.\"\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"/users\": {\n        \"get\": {\n          \"summary\": \"Get All Users\",\n          \"description\": \"Retrieve a list of all users. If a UID is provided in the query, it will return the specific user associated with that UID.\",\n          \"parameters\": [\n            {\n              \"name\": \"uid\",\n              \"in\": \"query\",\n              \"required\": false,\n              \"schema\": {\n                \"type\": \"string\"\n              },\n              \"description\": \"UID of the user to retrieve\"\n            }\n          ],\n          \"responses\": {\n            \"200\": {\n              \"description\": \"A list of users or a specific user\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                      \"type\": \"object\",\n                      \"properties\": {\n                        \"uid\": {\n                          \"type\": \"string\",\n                          \"example\": \"***\"\n                        },\n                        \"name\": {\n                          \"type\": \"string\",\n                          \"example\": \"John Doe\"\n                        },\n                        \"email\": {\n                          \"type\": \"string\",\n                          \"example\": \"jo***@example.com\"\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            \"404\": {\n              \"description\": \"User not found\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"message\": {\n                        \"type\": \"string\",\n                        \"example\": \"Invalid UID\"\n                      },\n                      \"status\": {\n                        \"type\": \"integer\",\n                        \"example\": 1\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            \"500\": {\n              \"description\": \"Invalid request\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"message\": {\n                        \"type\": \"string\",\n                        \"example\": \"Could not handle that request\"\n                      },\n                      \"status\": {\n                        \"type\": \"integer\",\n                        \"example\": 2\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"/sendInvite\": {\n        \"post\": {\n          \"summary\": \"Send Bond Invite\",\n          \"description\": \"Send a bond invitation from one user to another using their email addresses.\",\n          \"requestBody\": {\n            \"required\": true,\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"senderEmail\": {\n                      \"type\": \"string\",\n                      \"example\": \"sender@example.com\"\n                    },\n                    \"receiverEmail\": {\n                      \"type\": \"string\",\n                      \"example\": \"receiver@example.com\"\n                    }\n                  }\n                }\n              }\n            }\n          },\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Invite sent successfully\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"status\": {\n                        \"type\": \"string\",\n                        \"example\": \"sent\"\n                      },\n                      \"message\": {\n                        \"type\": \"string\",\n                        \"example\": \"Bond invite sent successfully to receiver@example.com\"\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            \"500\": {\n              \"description\": \"Error sending invite\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"message\": {\n                        \"type\": \"string\",\n                        \"example\": \"Error Posting request\"\n                      },\n                      \"status\": {\n                        \"type\": \"integer\",\n                        \"example\": 1\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"/user\": {\n        \"post\": {\n          \"summary\": \"Create or Login User\",\n          \"description\": \"Persist user data in the database to create a new user or log in an existing user.\",\n          \"requestBody\": {\n            \"required\": true,\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"uid\": {\n                      \"type\": \"string\",\n                      \"example\": \"12345\"\n                    },\n                    \"name\": {\n                      \"type\": \"string\",\n                      \"example\": \"John Doe\"\n                    },\n                    \"username\": {\n                      \"type\": \"string\",\n                      \"example\": \"johndoe\"\n                    },\n                    \"email\": {\n                      \"type\": \"string\",\n                      \"example\": \"john@example.com\"\n                    },\n                    \"photo\": {\n                      \"type\": \"string\",\n                      \"example\": \"photo_url\"\n                    }\n                  }\n                }\n              }\n            }\n          },\n          \"responses\": {\n            \"200\": {\n              \"description\": \"User created or logged in successfully\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                      \"type\": \"object\",\n                      \"properties\": {\n                        \"status\": {\n                          \"type\": \"string\",\n                          \"example\": \"signup\"\n                        },\n                        \"message\": {\n                          \"type\": \"string\",\n                          \"example\": \"John Doe account created successfully!\"\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n   \"/editUser\": {\n        \"post\": {\n            \"summary\": \"Edit User Info\",\n            \"description\": \"Edit the information of an existing user.\",\n            \"requestBody\": {\n            \"required\": true,\n            \"content\": {\n                \"application/json\": {\n                \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                    \"uid\": {\n                        \"type\": \"string\",\n                        \"example\": \"12345\"\n                    },\n                    \"username\": {\n                        \"type\": \"string\",\n                        \"example\": \"johndoe\"\n                    },\n                    \"photo\": {\n                        \"type\": \"string\",\n                        \"example\": \"new_photo_url\"\n                    }\n                    },\n                    \"required\": [\"uid\", \"username\", \"photo\"]\n                }\n                }\n            }\n            },\n            \"responses\": {\n            \"200\": {\n                \"description\": \"Profile updated successfully\",\n                \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"status\": {\n                        \"type\": \"integer\",\n                        \"example\": 0\n                        },\n                        \"message\": {\n                        \"type\": \"string\",\n                        \"example\": \"Profile updated successfully\"\n                        }\n                    }\n                    }\n                }\n                }\n            },\n            \"500\": {\n                \"description\": \"Invalid Field\",\n                \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"status\": {\n                        \"type\": \"integer\",\n                        \"example\": 1\n                        },\n                        \"message\": {\n                        \"type\": \"string\",\n                        \"example\": \"Invalid Field\"\n                        }\n                    }\n                    }\n                }\n                }\n            },\n            \"500(2)\": {\n                \"description\": \"Cannot update profile with empty fields\",\n                \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"status\": {\n                        \"type\": \"integer\",\n                        \"example\": 2\n                        },\n                        \"message\": {\n                        \"type\": \"string\",\n                        \"example\": \"Cannot update profile with empty fields\"\n                        }\n                    }\n                    }\n                }\n                }\n            },\n            \"500(3)\": {\n                \"description\": \"User ID doesn't exist\",\n                \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"status\": {\n                        \"type\": \"integer\",\n                        \"example\": 3\n                        },\n                        \"message\": {\n                        \"type\": \"string\",\n                        \"example\": \"User ID doesn't exist\"\n                        }\n                    }\n                    }\n                }\n                }\n            },\n            \"500(4)\": {\n                \"description\": \"Username already taken\",\n                \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"status\": {\n                        \"type\": \"integer\",\n                        \"example\": 4\n                        },\n                        \"message\": {\n                        \"type\": \"string\",\n                        \"example\": \"Username already taken\"\n                        }\n                    }\n                    }\n                }\n                }\n            }\n            }\n        }\n    },\n    \"/bondUsers\": {\n    \"post\": {\n        \"summary\": \"Bond Users\",\n        \"description\": \"Create a bond between two users.\",\n        \"requestBody\": {\n        \"required\": true,\n        \"content\": {\n            \"application/json\": {\n            \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                \"senderEncryptedEmail\": {\n                    \"type\": \"string\",\n                    \"example\": \"encrypted_email_string\"\n                },\n                \"receiverUid\": {\n                    \"type\": \"string\",\n                    \"example\": \"12345\"\n                }\n                },\n                \"required\": [\"senderEncryptedEmail\", \"receiverUid\"]\n            }\n            }\n        }\n        },\n        \"responses\": {\n        \"200\": {\n            \"description\": \"Bond Success!\",\n            \"content\": {\n            \"application/json\": {\n                \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"status\": {\n                    \"type\": \"integer\",\n                    \"example\": 0\n                    },\n                    \"message\": {\n                    \"type\": \"string\",\n                    \"example\": \"Bond Success!\"\n                    }\n                }\n                }\n            }\n            }\n        },\n        \"500(1)\": {\n            \"description\": \"Could not find user\",\n            \"content\": {\n            \"application/json\": {\n                \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"status\": {\n                    \"type\": \"integer\",\n                    \"example\": 1\n                    },\n                    \"message\": {\n                    \"type\": \"string\",\n                    \"example\": \"Could not find user\"\n                    }\n                }\n                }\n            }\n            }\n        },\n        \"500(2)\": {\n            \"description\": \"There was a problem executing the request\",\n            \"content\": {\n            \"application/json\": {\n                \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"status\": {\n                    \"type\": \"integer\",\n                    \"example\": 2\n                    },\n                    \"message\": {\n                    \"type\": \"string\",\n                    \"example\": \"There was a problem executing the request\"\n                    }\n                }\n                }\n            }\n            }\n        },\n        \"500(3)\": {\n            \"description\": \"Bond is already created\",\n            \"content\": {\n            \"application/json\": {\n                \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"status\": {\n                    \"type\": \"integer\",\n                    \"example\": 3\n                    },\n                    \"message\": {\n                    \"type\": \"string\",\n                    \"example\": \"Bond is already created\"\n                    }\n                }\n                }\n            }\n            }\n        }\n        }\n    }\n    },\n    \"/getBondedUsers/{uid}\": {\n        \"get\": {\n            \"summary\": \"Get Bonded Users\",\n            \"description\": \"Retrieve all users bonded with the target user.\",\n            \"parameters\": [\n            {\n                \"name\": \"uid\",\n                \"in\": \"path\",\n                \"required\": true,\n                \"description\": \"Unique ID of the target user\",\n                \"schema\": {\n                \"type\": \"string\",\n                \"example\": \"12345\"\n                }\n            }\n            ],\n            \"responses\": {\n            \"200\": {\n                \"description\": \"List of bonded users\",\n                \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                        \"room_id\": {\n                            \"type\": \"string\",\n                            \"example\": \"room_123\"\n                        },\n                        \"roomname\": {\n                            \"type\": \"string\",\n                            \"example\": \"John & Doe\"\n                        },\n                        \"person\": {\n                            \"type\": \"object\",\n                            \"properties\": {\n                            \"uid\": {\n                                \"type\": \"string\",\n                                \"example\": \"67890\"\n                            },\n                            \"name\": {\n                                \"type\": \"string\",\n                                \"example\": \"Jane Doe\"\n                            },\n                            \"email\": {\n                                \"type\": \"string\",\n                                \"example\": \"jane.doe@example.com\"\n                            }\n                            }\n                        }\n                        }\n                    }\n                    }\n                }\n                }\n            },\n            \"200(1)\": {\n                \"description\": \"No bonded users found\",\n                \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"status\": {\n                        \"type\": \"integer\",\n                        \"example\": 1\n                        },\n                        \"message\": {\n                        \"type\": \"string\",\n                        \"example\": \"No bonded users\"\n                        }\n                    }\n                    }\n                }\n                }\n            },\n            \"500\": {\n                \"description\": \"There was a problem executing the request\",\n                \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"status\": {\n                        \"type\": \"integer\",\n                        \"example\": 2\n                        },\n                        \"message\": {\n                        \"type\": \"string\",\n                        \"example\": \"There was a problem executing the request\"\n                        }\n                    }\n                    }\n                }\n                }\n            }\n            }\n        }\n    }\n    },\n    \"components\": {\n      \"securitySchemes\": {\n        \"bearerAuth\": {\n          \"type\": \"http\",\n          \"scheme\": \"bearer\",\n          \"bearerFormat\": \"JWT\"\n        }\n      },\n      \"schemas\": {\n        \"User\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"uid\": {\n              \"type\": \"string\",\n              \"example\": \"***\"\n            },\n            \"name\": {\n              \"type\": \"string\",\n              \"example\": \"John Doe\"\n            },\n            \"email\": {\n              \"type\": \"string\",\n              \"example\": \"jo***@example.com\"\n            }\n          }\n        }\n      }\n    },\n    \"security\": [\n      {\n        \"bearerAuth\": []\n      }\n    ]\n  }\n   [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\n\nconst express = require(\"express\");\nconst generateNews = require(\"./generateNews\");\nconst cors = require(\"cors\");\n\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\napp.use(cors());\napp.use(express.urlencoded({ extended: false }));\n\napp.get(\"/\", (req, res) => {\n  res.send({\n    message: \"Hello World\",\n  });\n});\n\napp.get(\"/api/news\", async (req, res) => {\n  try {\n    const news = await generateNews();\n    res.status(200).json(news);\n  } catch (error) {\n    console.error(`Error fetching news: ${error}`);\n    res.status(500).json({ error: \"Failed to fetch news\" });\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});\n\nBelow are the implementations:\n\nconst axios = require(\"axios\");\nconst cheerio = require(\"cheerio\");\nconst NodeCache = require(\"node-cache\");\nconst { newsUrls } = require(\"./newsUrls\");\n\nconst rssCache = new NodeCache();\n\nasync function generateNews() {\n  // An empty array to store the news items\n  let newsItems = [];\n\n  // Create an array of promises that fetch the RSS feeds\n  const rssPromises = newsUrls.map(async (url) => {\n    let response;\n    const cachedResponse = rssCache.get(url);\n    if (cachedResponse) {\n      response = { data: cachedResponse };\n    } else {\n      response = await axios.get(url, { timeout: 5000 });\n      rssCache.set(url, response.data);\n    }\n    const $ = cheerio.load(response.data, { xmlMode: true });\n    $(\"item\").each((i, item) => {\n      // Extract the required fields from the RSS item\n      const postUrl = $(item).find(\"link\").text();\n      const title = $(item).find(\"title\").text();\n      const thumbnail =\n        $(item).find(\"media\\\\:content, content\").attr(\"url\") ||\n        $(item).find(\"enclosure\").attr(\"url\") ||\n        $(item).find(\"image\").attr(\"url\") ||\n        $(item).find(\"og:image\").attr(\"content\") ||\n        $(item).find(\"twitter:image\").attr(\"content\") ||\n        \"https://via.placeholder.com/150\"; // Default thumbnail\n\n      const date = $(item).find(\"pubDate\").text();\n\n      // Add the news item to the array\n      newsItems.push({ postUrl, title, thumbnail, date });\n    });\n  });\n\n  // Wait for all the RSS feeds to be fetched and then return the news items\n  await Promise.allSettled(rssPromises);\n\n  return newsItems;\n}\n\nmodule.exports = generateNews;",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"server-api-doc\",\n        \"version\": \"1.0.0\",\n        \"description\": \"Get the latest tech news articles from popular websites through this API. Stay updated with tech trends effortlessly. Powered by React.js, Express.js, and Node.js.\",\n        \"termsOfService\": \"https://github.com/kabirjaipal/react-news-app/blob/main/LICENSE\",\n        \"contact\": {\n            \"name\": \"kabirjaipal\",\n            \"email\": \"example@gmail.com\",\n            \"url\": \"https://github.com/kabirjaipal\"\n        },\n        \"license\": {\n            \"name\": \"MIT\",\n            \"url\": \"https://github.com/kabirjaipal/react-news-app/blob/main/LICENSE\"\n        }\n    },\n    \"servers\": [\n        {\n            \"url\": \"https://localhost:3000\",\n            \"description\": \"development server\"\n        }\n    ],\n    \"paths\": {\n        \"/\": {\n            \"get\": {\n                \"summary\": \"Root endpoint\",\n                \"description\": \"Welcome message of the API to test the server connectivity. Returns a simple 'Hello World' message.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Success response\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"object\",\n                                    \"properties\": {\n                                        \"message\": {\n                                            \"type\": \"string\"\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        \"/api/news\": {\n            \"get\": {\n                \"summary\": \"Get Tech News\",\n                \"description\": \"Fetches the latest tech news articles from various sources. Returns an array of news items with post URL, title, thumbnail URL, and publication date.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Success response\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"type\": \"object\",\n                                        \"properties\": {\n                                            \"postUrl\": {\n                                                \"type\": \"string\"\n                                            },\n                                            \"title\": {\n                                                \"type\": \"string\"\n                                            },\n                                            \"thumbnail\": {\n                                                \"type\": \"string\"\n                                            },\n                                            \"date\": {\n                                                \"type\": \"string\"\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"Internal Server Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"object\",\n                                    \"properties\": {\n                                        \"error\": {\n                                            \"type\": \"string\"\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n} [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nconst express = require('express');\n\nconst feedController = require('../controllers/feed');\n\nconst router = express.Router();\n\n// GET /feed/posts\nrouter.get('/posts', feedController.getPosts);\n\n// POST /feed/post\nrouter.post('/post', feedController.createPost);\n\nmodule.exports = router;\n\nBelow are the implementations:\n\nexports.getPosts = (req, res, next) => {\n  res.status(200).json({\n    posts: [{ title: 'First Post', content: 'This is the first post' }]\n  });\n};\n\nexports.createPost = (req, res, next) => {\n  const title = req.body.title;\n  const content = req.body.content;\n  // Create post in db\n  res.status(201).json({\n    message: 'Post created successfully!',\n    post: {\n      id: new Date().toISOString(),\n      title: title,\n      content: content\n    }\n  });\n};",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n      \"title\": \"Node.js REST API Documentation\",\n      \"version\": \"1.0.0\",\n      \"description\": \"This API provides a simple interface for creating and retrieving posts. It is built using Node.js and follows REST principles, making it easy to integrate with other applications. The API supports basic operations like fetching a list of posts and creating new posts.\",\n      \"termsOfService\": \"https://gitlab.com/AdrianAntanon/nodejs-rest-api\",\n      \"contact\": {\n        \"name\": \"Adrian Antanon\",\n        \"email\": \"example@gmail.com\",\n        \"url\": \"https://gitlab.com/AdrianAntanon\"\n      },\n      \"license\": {\n        \"name\": \"ISC\",\n        \"url\": \"https://gitlab.com/AdrianAntanon/nodejs-rest-api\"\n      }\n    },\n    \"servers\": [\n      {\n        \"url\": \"https://localhost:3000\",\n        \"description\": \"Development server\"\n      }\n    ],\n    \"paths\": {\n      \"/feed/posts\": {\n        \"get\": {\n          \"summary\": \"Retrieve a list of posts\",\n          \"description\": \"This endpoint allows you to fetch a list of posts that have been created. Each post contains a title and content. This is useful for displaying posts to users or for further processing within your application.\",\n          \"responses\": {\n            \"200\": {\n              \"description\": \"A list of posts\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"posts\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                          \"type\": \"object\",\n                          \"properties\": {\n                            \"title\": {\n                              \"type\": \"string\",\n                              \"example\": \"First Post\"\n                            },\n                            \"content\": {\n                              \"type\": \"string\",\n                              \"example\": \"This is the first post\"\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"/feed/post\": {\n        \"post\": {\n          \"summary\": \"Create a new post\",\n          \"description\": \"This endpoint allows you to create a new post by providing a title and content. The post will be saved and can later be retrieved using the GET /feed/posts endpoint. This is useful for adding new content to your application.\",\n          \"requestBody\": {\n            \"description\": \"The post to create\",\n            \"required\": true,\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"title\": {\n                      \"type\": \"string\",\n                      \"example\": \"New Post\"\n                    },\n                    \"content\": {\n                      \"type\": \"string\",\n                      \"example\": \"This is the content of the new post\"\n                    }\n                  },\n                  \"required\": [\"title\", \"content\"]\n                }\n              }\n            }\n          },\n          \"responses\": {\n            \"201\": {\n              \"description\": \"Post created successfully\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"message\": {\n                        \"type\": \"string\",\n                        \"example\": \"Post created successfully!\"\n                      },\n                      \"post\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                          \"id\": {\n                            \"type\": \"string\",\n                            \"example\": \"2023-08-12T12:00:00Z\"\n                          },\n                          \"title\": {\n                            \"type\": \"string\",\n                            \"example\": \"New Post\"\n                          },\n                          \"content\": {\n                            \"type\": \"string\",\n                            \"example\": \"This is the content of the new post\"\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            \"400\": {\n              \"description\": \"Invalid input data\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"message\": {\n                        \"type\": \"string\",\n                        \"example\": \"Invalid data provided\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nconst express = require('express');\nconst router = express.Router();\nconst recipeController = require('../controllers/recipe_controller');\n\nrouter.get(\"/v1/recipes\", recipeController.getAllRecipes);\nrouter.get(\"/v1/recipe/random\", recipeController.getRandomRecipe);\nrouter.get(\"/v1/recipe/category/:category\", recipeController.getRecipesByCategory);\nrouter.get(\"/v1/recipe/difficulty/:level\", recipeController.getRecipesByDifficulty);\nrouter.post(\"/v1/recipe\", recipeController.addNewRecipe);\nrouter.get(\"/v1/recipe/:id\", recipeController.getRecipeById);\nrouter.put(\"/v1/recipe/:id\", recipeController.updateRecipe);\nrouter.delete(\"/v1/recipe/:id\", recipeController.deleteRecipe);\n\nmodule.exports = router;\n\nBelow are the implementations:\n\nconst recipes = require(\"../recipes\");\n\nfunction getRandomRecipe() {\n  return recipes[Math.floor(Math.random() * recipes.length)];\n}\n\nexports.getAllRecipes = (req, res) => {\n  res.send(recipes);\n};\n\nexports.getRandomRecipe = (req, res) => {\n  res.send(getRandomRecipe());\n};\n\nexports.getRecipesByCategory = (req, res) => {\n  const category = req.params.category.toLowerCase();\n  const filteredRecipes = recipes.filter(recipe => recipe.category.toLowerCase() === category);\n  res.send(filteredRecipes);\n};\n\nexports.getRecipesByDifficulty = (req, res) => {\n  const difficulty = req.params.level.toLowerCase();\n  const filteredRecipes = recipes.filter(recipe => recipe.difficulty.toLowerCase() === difficulty);\n  res.send(filteredRecipes);\n};\n\nexports.addNewRecipe = (req, res) => {\n  const newRecipe = req.body;\n  newRecipe.id = recipes.length + 1;\n  recipes.push(newRecipe);\n  res.status(201).send(newRecipe);\n};\n\nexports.getRecipeById = (req, res) => {\n  const id = parseInt(req.params.id);\n  const recipe = recipes.find(r => r.id === id);\n  if (recipe) {\n    res.send(recipe);\n  } else {\n    res.status(404).send({ error: \"Recipe not found\" });\n  }\n};\n\nexports.updateRecipe = (req, res) => {\n  const id = parseInt(req.params.id);\n  const index = recipes.findIndex(r => r.id === id);\n  if (index !== -1) {\n    recipes[index] = { ...recipes[index], ...req.body, id };\n    res.send(recipes[index]);\n  } else {\n    res.status(404).send({ error: \"Recipe not found\" });\n  }\n};\n\nexports.deleteRecipe = (req, res) => {\n  const id = parseInt(req.params.id);\n  const index = recipes.findIndex(r => r.id === id);\n  if (index !== -1) {\n    recipes.splice(index, 1);\n    res.status(204).send();\n  } else {\n    res.status(404).send({ error: \"Recipe not found\" });\n  }\n};",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n      \"title\": \"Recipe API\",\n      \"version\": \"1.0.0\",\n      \"description\": \"The Recipe API provides a comprehensive set of endpoints for managing and retrieving recipes. It allows users to get all recipes, retrieve random recipes, filter recipes by category and difficulty, add new recipes, update existing ones, and delete recipes.\"\n    },\n    \"servers\": [\n      {\n        \"url\": \"https://api.recipeapp.com/v1\",\n        \"description\": \"Production server\"\n      },\n      {\n        \"url\": \"https://staging.recipeapp.com/v1\",\n        \"description\": \"Staging server\"\n      }\n    ],\n    \"paths\": {\n      \"/recipes\": {\n        \"get\": {\n          \"summary\": \"Get all recipes\",\n          \"description\": \"Retrieve all recipes available in the API's database.\",\n          \"responses\": {\n            \"200\": {\n              \"description\": \"A list of all recipes was successfully retrieved.\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                      \"$ref\": \"#/components/schemas/Recipe\"\n                    }\n                  }\n                }\n              }\n            },\n            \"500\": {\n              \"description\": \"An internal error occurred while retrieving the recipes.\"\n            }\n          }\n        }\n      },\n      \"/recipe/random\": {\n        \"get\": {\n          \"summary\": \"Get a random recipe\",\n          \"description\": \"Retrieve a single random recipe from the collection.\",\n          \"responses\": {\n            \"200\": {\n              \"description\": \"A random recipe was successfully retrieved.\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"$ref\": \"#/components/schemas/Recipe\"\n                  }\n                }\n              }\n            },\n            \"500\": {\n              \"description\": \"An internal error occurred while retrieving the recipe.\"\n            }\n          }\n        }\n      },\n      \"/recipe/category/{category}\": {\n        \"get\": {\n          \"summary\": \"Get recipes by category\",\n          \"description\": \"Retrieve all recipes that belong to a specific category.\",\n          \"parameters\": [\n            {\n              \"name\": \"category\",\n              \"in\": \"path\",\n              \"required\": true,\n              \"schema\": {\n                \"type\": \"string\"\n              }\n            }\n          ],\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Recipes in the specified category were successfully retrieved.\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                      \"$ref\": \"#/components/schemas/Recipe\"\n                    }\n                  }\n                }\n              }\n            },\n            \"404\": {\n              \"description\": \"No recipes were found in the specified category.\"\n            },\n            \"500\": {\n              \"description\": \"An internal error occurred while retrieving the recipes.\"\n            }\n          }\n        }\n      },\n      \"/recipe/difficulty/{level}\": {\n        \"get\": {\n          \"summary\": \"Get recipes by difficulty\",\n          \"description\": \"Retrieve all recipes that match a specific difficulty level.\",\n          \"parameters\": [\n            {\n              \"name\": \"level\",\n              \"in\": \"path\",\n              \"required\": true,\n              \"schema\": {\n                \"type\": \"string\",\n                \"enum\": [\n                  \"easy\",\n                  \"medium\",\n                  \"hard\"\n                ]\n              }\n            }\n          ],\n          \"responses\": {\n            \"200\": {\n              \"description\": \"Recipes of the specified difficulty were successfully retrieved.\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                      \"$ref\": \"#/components/schemas/Recipe\"\n                    }\n                  }\n                }\n              }\n            },\n            \"404\": {\n              \"description\": \"No recipes were found with the specified difficulty level.\"\n            },\n            \"500\": {\n              \"description\": \"An internal error occurred while retrieving the recipes.\"\n            }\n          }\n        }\n      },\n      \"/recipe\": {\n        \"post\": {\n          \"summary\": \"Add a new recipe\",\n          \"description\": \"Add a new recipe to the collection.\",\n          \"requestBody\": {\n            \"required\": true,\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/NewRecipe\"\n                }\n              }\n            }\n          },\n          \"responses\": {\n            \"201\": {\n              \"description\": \"The recipe was successfully added.\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"$ref\": \"#/components/schemas/Recipe\"\n                  }\n                }\n              }\n            },\n            \"400\": {\n              \"description\": \"The request body is invalid.\"\n            },\n            \"500\": {\n              \"description\": \"An internal error occurred while adding the recipe.\"\n            }\n          }\n        }\n      },\n      \"/recipe/{id}\": {\n        \"get\": {\n          \"summary\": \"Get a recipe by ID\",\n          \"description\": \"Retrieve a specific recipe by its ID.\",\n          \"parameters\": [\n            {\n              \"name\": \"id\",\n              \"in\": \"path\",\n              \"required\": true,\n              \"schema\": {\n                \"type\": \"integer\"\n              }\n            }\n          ],\n          \"responses\": {\n            \"200\": {\n              \"description\": \"The recipe was successfully retrieved.\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"$ref\": \"#/components/schemas/Recipe\"\n                  }\n                }\n              }\n            },\n            \"404\": {\n              \"description\": \"The recipe with the specified ID was not found.\"\n            },\n            \"500\": {\n              \"description\": \"An internal error occurred while retrieving the recipe.\"\n            }\n          }\n        },\n        \"put\": {\n          \"summary\": \"Update a recipe\",\n          \"description\": \"Update an existing recipe by its ID.\",\n          \"parameters\": [\n            {\n              \"name\": \"id\",\n              \"in\": \"path\",\n              \"required\": true,\n              \"schema\": {\n                \"type\": \"integer\"\n              }\n            }\n          ],\n          \"requestBody\": {\n            \"required\": true,\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/NewRecipe\"\n                }\n              }\n            }\n          },\n          \"responses\": {\n            \"200\": {\n              \"description\": \"The recipe was successfully updated.\",\n              \"content\": {\n                \"application/json\": {\n                  \"schema\": {\n                    \"$ref\": \"#/components/schemas/Recipe\"\n                  }\n                }\n              }\n            },\n            \"400\": {\n              \"description\": \"The request body is invalid.\"\n            },\n            \"404\": {\n              \"description\": \"The recipe with the specified ID was not found.\"\n            },\n            \"500\": {\n              \"description\": \"An internal error occurred while updating the recipe.\"\n            }\n          }\n        },\n        \"delete\": {\n          \"summary\": \"Delete a recipe\",\n          \"description\": \"Delete an existing recipe by its ID.\",\n          \"parameters\": [\n            {\n              \"name\": \"id\",\n              \"in\": \"path\",\n              \"required\": true,\n              \"schema\": {\n                \"type\": \"integer\"\n              }\n            }\n          ],\n          \"responses\": {\n            \"204\": {\n              \"description\": \"The recipe was successfully deleted.\"\n            },\n            \"404\": {\n              \"description\": \"The recipe with the specified ID was not found.\"\n            },\n            \"500\": {\n              \"description\": \"An internal error occurred while deleting the recipe.\"\n            }\n          }\n        }\n      }\n    },\n    \"components\": {\n      \"schemas\": {\n        \"Recipe\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"id\": {\n              \"type\": \"integer\"\n            },\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"category\": {\n              \"type\": \"string\"\n            },\n            \"difficulty\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"easy\",\n                \"medium\",\n                \"hard\"\n              ]\n            },\n            \"ingredients\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"string\"\n              }\n            },\n            \"instructions\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"string\"\n              }\n            },\n            \"prepTime\": {\n              \"type\": \"integer\",\n              \"description\": \"Preparation time in minutes\"\n            },\n            \"cookTime\": {\n              \"type\": \"integer\",\n              \"description\": \"Cooking time in minutes\"\n            }\n          },\n          \"required\": [\n            \"id\",\n            \"name\",\n            \"category\",\n            \"difficulty\",\n            \"ingredients\",\n            \"instructions\",\n            \"prepTime\",\n            \"cookTime\"\n          ]\n        },\n        \"NewRecipe\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"name\": {\n              \"type\": \"string\"\n            },\n            \"category\": {\n              \"type\": \"string\"\n            },\n            \"difficulty\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"easy\",\n                \"medium\",\n                \"hard\"\n              ]\n            },\n            \"ingredients\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"string\"\n              }\n            },\n            \"instructions\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"string\"\n              }\n            },\n            \"prepTime\": {\n              \"type\": \"integer\",\n              \"description\": \"Preparation time in minutes\"\n            },\n            \"cookTime\": {\n              \"type\": \"integer\",\n              \"description\": \"Cooking time in minutes\"\n            }\n          },\n          \"required\": [\n            \"name\",\n            \"category\",\n            \"difficulty\",\n            \"ingredients\",\n            \"instructions\",\n            \"prepTime\",\n            \"cookTime\"\n          ]\n        }\n      }\n    }\n  } [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nconst express = require('express');\nconst router = express.Router();\nconst taskController = require('../controllers/task_controller');\n\nrouter.get(\"/v1/tasks\", taskController.getAllTasks);\nrouter.post(\"/v1/tasks\", taskController.createTask);\nrouter.get(\"/v1/tasks/:id\", taskController.getTaskById);\nrouter.put(\"/v1/tasks/:id\", taskController.updateTask);\nrouter.delete(\"/v1/tasks/:id\", taskController.deleteTask);\nrouter.get(\"/v1/tasks/status/:status\", taskController.getTasksByStatus);\nrouter.get(\"/v1/tasks/priority/:priority\", taskController.getTasksByPriority);\nrouter.put(\"/v1/tasks/:id/complete\", taskController.markTaskAsComplete);\n\nmodule.exports = router;\n\nBelow are the implementations:\n\nconst tasks = require(\"../tasks\");\n\nexports.getAllTasks = (req, res) => {\n  res.send(tasks);\n};\n\nexports.createTask = (req, res) => {\n  const newTask = {\n    id: tasks.length + 1,\n    ...req.body,\n    createdAt: new Date().toISOString(),\n    completed: false\n  };\n  tasks.push(newTask);\n  res.status(201).send(newTask);\n};\n\nexports.getTaskById = (req, res) => {\n  const id = parseInt(req.params.id);\n  const task = tasks.find(t => t.id === id);\n  if (task) {\n    res.send(task);\n  } else {\n    res.status(404).send({ error: \"Task not found\" });\n  }\n};\n\nexports.updateTask = (req, res) => {\n  const id = parseInt(req.params.id);\n  const index = tasks.findIndex(t => t.id === id);\n  if (index !== -1) {\n    tasks[index] = { ...tasks[index], ...req.body, id };\n    res.send(tasks[index]);\n  } else {\n    res.status(404).send({ error: \"Task not found\" });\n  }\n};\n\nexports.deleteTask = (req, res) => {\n  const id = parseInt(req.params.id);\n  const index = tasks.findIndex(t => t.id === id);\n  if (index !== -1) {\n    tasks.splice(index, 1);\n    res.status(204).send();\n  } else {\n    res.status(404).send({ error: \"Task not found\" });\n  }\n};\n\nexports.getTasksByStatus = (req, res) => {\n  const status = req.params.status.toLowerCase();\n  const filteredTasks = tasks.filter(task => task.status.toLowerCase() === status);\n  res.send(filteredTasks);\n};\n\nexports.getTasksByPriority = (req, res) => {\n  const priority = req.params.priority.toLowerCase();\n  const filteredTasks = tasks.filter(task => task.priority.toLowerCase() === priority);\n  res.send(filteredTasks);\n};\n\nexports.markTaskAsComplete = (req, res) => {\n  const id = parseInt(req.params.id);\n  const task = tasks.find(t => t.id === id);\n  if (task) {\n    task.completed = true;\n    task.completedAt = new Date().toISOString();\n    res.send(task);\n  } else {\n    res.status(404).send({ error: \"Task not found\" });\n  }\n};",
    "answer": "[SPEC] {\n  \"openapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"Task Management API\",\n    \"version\": \"1.0.0\",\n    \"description\": \"The Task Management API provides a set of endpoints for creating, retrieving, updating, and deleting tasks. It also allows filtering tasks by status and priority.\"\n  },\n  \"servers\": [\n    {\n      \"url\": \"https://api.taskmanager.com/v1\",\n      \"description\": \"Production server\"\n    },\n    {\n      \"url\": \"https://staging.taskmanager.com/v1\",\n      \"description\": \"Staging server\"\n    }\n  ],\n  \"paths\": {\n    \"/tasks\": {\n      \"get\": {\n        \"summary\": \"Get all tasks\",\n        \"description\": \"Retrieve all tasks available in the system.\",\n        \"responses\": {\n          \"200\": {\n            \"description\": \"A list of all tasks was successfully retrieved.\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"$ref\": \"#/components/schemas/Task\"\n                  }\n                }\n              }\n            }\n          },\n          \"500\": {\n            \"description\": \"An internal error occurred while retrieving the tasks.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new task\",\n        \"description\": \"Create a new task in the system.\",\n        \"requestBody\": {\n          \"required\": true,\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/NewTask\"\n              }\n            }\n          }\n        },\n        \"responses\": {\n          \"201\": {\n            \"description\": \"The task was successfully created.\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/Task\"\n                }\n              }\n            }\n          },\n          \"400\": {\n            \"description\": \"The request body is invalid.\"\n          },\n          \"500\": {\n            \"description\": \"An internal error occurred while creating the task.\"\n          }\n        }\n      }\n    },\n    \"/tasks/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a task by ID\",\n        \"description\": \"Retrieve a specific task by its ID.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"required\": true,\n            \"schema\": {\n              \"type\": \"integer\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"The task was successfully retrieved.\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/Task\"\n                }\n              }\n            }\n          },\n          \"404\": {\n            \"description\": \"The task with the specified ID was not found.\"\n          },\n          \"500\": {\n            \"description\": \"An internal error occurred while retrieving the task.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a task\",\n        \"description\": \"Update an existing task by its ID.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"required\": true,\n            \"schema\": {\n              \"type\": \"integer\"\n            }\n          }\n        ],\n        \"requestBody\": {\n          \"required\": true,\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/UpdateTask\"\n              }\n            }\n          }\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"The task was successfully updated.\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/Task\"\n                }\n              }\n            }\n          },\n          \"404\": {\n            \"description\": \"The task with the specified ID was not found.\"\n          },\n          \"400\": {\n            \"description\": \"The request body is invalid.\"\n          },\n          \"500\": {\n            \"description\": \"An internal error occurred while updating the task.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a task\",\n        \"description\": \"Delete an existing task by its ID.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"required\": true,\n            \"schema\": {\n              \"type\": \"integer\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"204\": {\n            \"description\": \"The task was successfully deleted.\"\n          },\n          \"404\": {\n            \"description\": \"The task with the specified ID was not found.\"\n          },\n          \"500\": {\n            \"description\": \"An internal error occurred while deleting the task.\"\n          }\n        }\n      }\n    },\n    \"/tasks/status/{status}\": {\n      \"get\": {\n        \"summary\": \"Get tasks by status\",\n        \"description\": \"Retrieve all tasks that match a specific status.\",\n        \"parameters\": [\n          {\n            \"name\": \"status\",\n            \"in\": \"path\",\n            \"required\": true,\n            \"schema\": {\n              \"type\": \"string\",\n              \"enum\": [\"pending\", \"in-progress\", \"completed\"]\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Tasks with the specified status were successfully retrieved.\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"$ref\": \"#/components/schemas/Task\"\n                  }\n                }\n              }\n            }\n          },\n          \"500\": {\n            \"description\": \"An internal error occurred while retrieving the tasks.\"\n          }\n        }\n      }\n    },\n    \"/tasks/priority/{priority}\": {\n      \"get\": {\n        \"summary\": \"Get tasks by priority\",\n        \"description\": \"Retrieve all tasks that match a specific priority.\",\n        \"parameters\": [\n          {\n            \"name\": \"priority\",\n            \"in\": \"path\",\n            \"required\": true,\n            \"schema\": {\n              \"type\": \"string\",\n              \"enum\": [\"low\", \"medium\", \"high\"]\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Tasks with the specified priority were successfully retrieved.\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"$ref\": \"#/components/schemas/Task\"\n                  }\n                }\n              }\n            }\n          },\n          \"500\": {\n            \"description\": \"An internal error occurred while retrieving the tasks.\"\n          }\n        }\n      }\n    },\n    \"/tasks/{id}/complete\": {\n      \"put\": {\n        \"summary\": \"Mark a task as complete\",\n        \"description\": \"Mark an existing task as completed by its ID.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"required\": true,\n            \"schema\": {\n              \"type\": \"integer\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"The task was successfully marked as complete.\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/Task\"\n                }\n              }\n            }\n          },\n          \"404\": {\n            \"description\": \"The task with the specified ID was not found.\"\n          },\n          \"500\": {\n            \"description\": \"An internal error occurred while updating the task.\"\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"Task\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\"\n          },\n          \"title\": {\n            \"type\": \"string\"\n          },\n          \"description\": {\n            \"type\": \"string\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"enum\": [\"pending\", \"in-progress\", \"completed\"]\n          },\n          \"priority\": {\n            \"type\": \"string\",\n            \"enum\": [\"low\", \"medium\", \"high\"]\n          },\n          \"createdAt\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          },\n          \"completedAt\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          },\n          \"completed\": {\n            \"type\": \"boolean\"\n          }\n        },\n        \"required\": [\"id\", \"title\", \"status\", \"priority\", \"createdAt\", \"completed\"]\n      },\n      \"NewTask\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"title\": {\n            \"type\": \"string\"\n          },\n          \"description\": {\n            \"type\": \"string\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"enum\": [\"pending\", \"in-progress\", \"completed\"]\n          },\n          \"priority\": {\n            \"type\": \"string\",\n            \"enum\": [\"low\", \"medium\", \"high\"]\n          }\n        },\n        \"required\": [\"title\", \"status\", \"priority\"]\n      },\n      \"UpdateTask\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"title\": {\n            \"type\": \"string\"\n          },\n          \"description\": {\n            \"type\": \"string\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"enum\": [\"pending\", \"in-progress\", \"completed\"]\n          },\n          \"priority\": {\n            \"type\": \"string\",\n            \"enum\": [\"low\", \"medium\", \"high\"]\n          }\n        }\n      }\n    }\n  }\n} [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nconst express = require('express');\nconst router = express.Router();\nconst todoController = require('../controllers/todo_controller');\n\nrouter.get(\"/v1/todos\", todoController.getAllTodos);\nrouter.get(\"/v1/todo/random\", todoController.getRandomTodo);\nrouter.post(\"/v1/todo\", todoController.createTodo);\nrouter.get(\"/v1/todo/:id\", todoController.getTodoById);\nrouter.put(\"/v1/todo/:id\", todoController.updateTodo);\nrouter.delete(\"/v1/todo/:id\", todoController.deleteTodo);\nrouter.get(\"/v1/todos/status/:status\", todoController.getTodosByStatus);\nrouter.get(\"/v1/todos/priority/:priority\", todoController.getTodosByPriority);\nrouter.put(\"/v1/todo/:id/complete\", todoController.markTodoAsComplete);\n\nmodule.exports = router;\n\nBelow are the implementations:\n\nconst todos = require(\"../todos\");\n\nfunction getRandomTodo() {\n  return todos[Math.floor(Math.random() * todos.length)];\n}\n\nexports.getAllTodos = (req, res) => {\n  res.send(todos);\n};\n\nexports.getRandomTodo = (req, res) => {\n  res.send(getRandomTodo());\n};\n\nexports.createTodo = (req, res) => {\n  const newTodo = {\n    id: todos.length + 1,\n    ...req.body,\n    createdAt: new Date().toISOString(),\n    completed: false\n  };\n  todos.push(newTodo);\n  res.status(201).send(newTodo);\n};\n\nexports.getTodoById = (req, res) => {\n  const id = parseInt(req.params.id);\n  const todo = todos.find(t => t.id === id);\n  if (todo) {\n    res.send(todo);\n  } else {\n    res.status(404).send({ error: \"Todo not found\" });\n  }\n};\n\nexports.updateTodo = (req, res) => {\n  const id = parseInt(req.params.id);\n  const index = todos.findIndex(t => t.id === id);\n  if (index !== -1) {\n    todos[index] = { ...todos[index], ...req.body, id };\n    res.send(todos[index]);\n  } else {\n    res.status(404).send({ error: \"Todo not found\" });\n  }\n};\n\nexports.deleteTodo = (req, res) => {\n  const id = parseInt(req.params.id);\n  const index = todos.findIndex(t => t.id === id);\n  if (index !== -1) {\n    todos.splice(index, 1);\n    res.status(204).send();\n  } else {\n    res.status(404).send({ error: \"Todo not found\" });\n  }\n};\n\nexports.getTodosByStatus = (req, res) => {\n  const status = req.params.status.toLowerCase();\n  const filteredTodos = todos.filter(todo => todo.status.toLowerCase() === status);\n  res.send(filteredTodos);\n};\n\nexports.getTodosByPriority = (req, res) => {\n  const priority = req.params.priority.toLowerCase();\n  const filteredTodos = todos.filter(todo => todo.priority.toLowerCase() === priority);\n  res.send(filteredTodos);\n};\n\nexports.markTodoAsComplete = (req, res) => {\n  const id = parseInt(req.params.id);\n  const todo = todos.find(t => t.id === id);\n  if (todo) {\n    todo.completed = true;\n    todo.completedAt = new Date().toISOString();\n    res.send(todo);\n  } else {\n    res.status(404).send({ error: \"Todo not found\" });\n  }\n};\n",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"To-Do List API\",\n        \"version\": \"1.0.0\",\n        \"description\": \"The To-Do List API provides a comprehensive set of endpoints for managing and retrieving to-do items. It allows users to create, read, update, and delete to-do items, as well as filter them by status and priority. The API also includes features like retrieving a random to-do item and marking items as complete.\",\n        \"termsOfService\": \"https://example.com/terms\",\n        \"contact\": {\n            \"name\": \"API Support\",\n            \"email\": \"support@todolistapi.com\",\n            \"url\": \"https://www.todolistapi.com/support\"\n        },\n        \"license\": {\n            \"name\": \"Apache 2.0\",\n            \"url\": \"https://www.apache.org/licenses/LICENSE-2.0\"\n        }\n    },\n    \"servers\": [\n        {\n            \"url\": \"https://api.todolistapi.com/v1\",\n            \"description\": \"Production server\"\n        },\n        {\n            \"url\": \"https://staging.todolistapi.com/v1\",\n            \"description\": \"Staging server\"\n        }\n    ],\n    \"paths\": {\n        \"/todos\": {\n            \"get\": {\n                \"summary\": \"Get all to-do items\",\n                \"description\": \"Retrieve all to-do items available in the API's database. This endpoint provides access to the entire collection of to-do items, allowing for a complete list to be retrieved in a single call. It's useful for applications that need to display or process all to-do items at once.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"A complete list of to-do items was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Todo\"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the to-do items.\"\n                    }\n                }\n            }\n        },\n        \"/todo/random\": {\n            \"get\": {\n                \"summary\": \"Get random to-do item\",\n                \"description\": \"Retrieve a single random to-do item from the collection. This endpoint selects one to-do item at random, providing a fresh and unexpected item each time it is called. It's ideal for features that need to show a daily or periodically changing to-do item.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"A random to-do item was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Todo\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the to-do item.\"\n                    }\n                }\n            }\n        },\n        \"/todo\": {\n            \"post\": {\n                \"summary\": \"Create a new to-do item\",\n                \"description\": \"Add a new to-do item to the collection. This endpoint allows users to create a new to-do item by providing the necessary details in the request body. The API will automatically assign an ID and set the creation timestamp.\",\n                \"requestBody\": {\n                    \"required\": true,\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/NewTodo\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"201\": {\n                        \"description\": \"The to-do item was successfully created.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Todo\"\n                                }\n                            }\n                        }\n                    },\n                    \"400\": {\n                        \"description\": \"The request body is invalid. Ensure all required fields are provided and in the correct format.\"\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to create the to-do item.\"\n                    }\n                }\n            }\n        },\n        \"/todo/{id}\": {\n            \"get\": {\n                \"summary\": \"Get a to-do item by ID\",\n                \"description\": \"Retrieve a specific to-do item by its ID. This endpoint allows users to fetch the details of a particular to-do item when they know its unique identifier.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"description\": \"The unique identifier of the to-do item.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The to-do item was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Todo\"\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"The to-do item with the specified ID was not found.\"\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the to-do item.\"\n                    }\n                }\n            },\n            \"put\": {\n                \"summary\": \"Update a to-do item\",\n                \"description\": \"Update an existing to-do item by its ID. This endpoint allows users to modify the details of a specific to-do item. The request body should contain the fields to be updated.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"description\": \"The unique identifier of the to-do item to be updated.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                ],\n                \"requestBody\": {\n                    \"required\": true,\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/UpdateTodo\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The to-do item was successfully updated.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Todo\"\n                                }\n                            }\n                        }\n                    },\n                    \"400\": {\n                        \"description\": \"The request body is invalid. Ensure the provided fields are in the correct format.\"\n                    },\n                    \"404\": {\n                        \"description\": \"The to-do item with the specified ID was not found.\"\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to update the to-do item.\"\n                    }\n                }\n            },\n            \"delete\": {\n                \"summary\": \"Delete a to-do item\",\n                \"description\": \"Delete an existing to-do item by its ID. This endpoint allows users to remove a specific to-do item from the collection.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"description\": \"The unique identifier of the to-do item to be deleted.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"204\": {\n                        \"description\": \"The to-do item was successfully deleted.\"\n                    },\n                    \"404\": {\n                        \"description\": \"The to-do item with the specified ID was not found.\"\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to delete the to-do item.\"\n                    }\n                }\n            }\n        },\n        \"/todos/status/{status}\": {\n            \"get\": {\n                \"summary\": \"Get to-do items by status\",\n                \"description\": \"Retrieve all to-do items that match a specific status. This endpoint allows filtering of to-do items based on their current status, such as 'pending', 'in-progress', or 'completed'.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"status\",\n                        \"in\": \"path\",\n                        \"description\": \"The status to filter the to-do items by.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\",\n                            \"enum\": [\"pending\", \"in-progress\", \"completed\"]\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"To-do items with the specified status were successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Todo\"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the to-do items.\"\n                    }\n                }\n            }\n        },\n        \"/todos/priority/{priority}\": {\n            \"get\": {\n                \"summary\": \"Get to-do items by priority\",\n                \"description\": \"Retrieve all to-do items that match a specific priority. This endpoint allows filtering of to-do items based on their assigned priority, such as 'low', 'medium', or 'high'.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"priority\",\n                        \"in\": \"path\",\n                        \"description\": \"The priority to filter the to-do items by.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\",\n                            \"enum\": [\"low\", \"medium\", \"high\"]\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"To-do items with the specified priority were successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Todo\"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the to-do items.\"\n                    }\n                }\n            }\n        },\n        \"/todo/{id}/complete\": {\n            \"patch\": {\n                \"summary\": \"Mark a to-do item as complete\",\n                \"description\": \"Update a specific to-do item to mark it as complete. This endpoint changes the status of the to-do item to 'completed'.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"description\": \"The unique identifier of the to-do item to be marked as complete.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The to-do item was successfully marked as complete.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Todo\"\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"The to-do item with the specified ID was not found.\"\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to mark the to-do item as complete.\"\n                    }\n                }\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"Todo\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"id\": {\n                        \"type\": \"integer\",\n                        \"description\": \"The unique identifier of the to-do item.\"\n                    },\n                    \"title\": {\n                        \"type\": \"string\",\n                        \"description\": \"The title of the to-do item.\"\n                    },\n                    \"description\": {\n                        \"type\": \"string\",\n                        \"description\": \"A detailed description of the to-do item.\"\n                    },\n                    \"status\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"pending\", \"in-progress\", \"completed\"],\n                        \"description\": \"The current status of the to-do item.\"\n                    },\n                    \"priority\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"low\", \"medium\", \"high\"],\n                        \"description\": \"The priority level of the to-do item.\"\n                    },\n                    \"created_at\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"description\": \"The timestamp when the to-do item was created.\"\n                    },\n                    \"updated_at\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"description\": \"The timestamp when the to-do item was last updated.\"\n                    }\n                }\n            },\n            \"NewTodo\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"title\": {\n                        \"type\": \"string\",\n                        \"description\": \"The title of the to-do item.\",\n                        \"example\": \"Buy groceries\"\n                    },\n                    \"description\": {\n                        \"type\": \"string\",\n                        \"description\": \"A detailed description of the to-do item.\",\n                        \"example\": \"Buy milk, eggs, and bread from the store.\"\n                    },\n                    \"priority\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"low\", \"medium\", \"high\"],\n                        \"description\": \"The priority level of the to-do item.\",\n                        \"example\": \"medium\"\n                    }\n                },\n                \"required\": [\"title\", \"description\", \"priority\"]\n            },\n            \"UpdateTodo\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"title\": {\n                        \"type\": \"string\",\n                        \"description\": \"The title of the to-do item.\",\n                        \"example\": \"Buy groceries\"\n                    },\n                    \"description\": {\n                        \"type\": \"string\",\n                        \"description\": \"A detailed description of the to-do item.\",\n                        \"example\": \"Buy milk, eggs, and bread from the store.\"\n                    },\n                    \"status\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"pending\", \"in-progress\", \"completed\"],\n                        \"description\": \"The current status of the to-do item.\",\n                        \"example\": \"in-progress\"\n                    },\n                    \"priority\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"low\", \"medium\", \"high\"],\n                        \"description\": \"The priority level of the to-do item.\",\n                        \"example\": \"medium\"\n                    }\n                }\n            }\n        }\n    }\n} [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nconst express = require('express');\nconst router = express.Router();\nconst bookController = require('../controllers/book_controller');\n\n// Get all books\nrouter.get(\"/v1/books\", bookController.getAllBooks);\n\n// Get a single book by ID\nrouter.get(\"/v1/book/:id\", bookController.getBookById);\n\n// Add a new book\nrouter.post(\"/v1/book\", bookController.addBook);\n\n// Update a book by ID\nrouter.put(\"/v1/book/:id\", bookController.updateBook);\n\n// Delete a book by ID\nrouter.delete(\"/v1/book/:id\", bookController.deleteBook);\n\nmodule.exports = router;\n\n\nBelow are the implementations:\n\nconst books = require(\"../books\");\n\n// Get all books\nexports.getAllBooks = (req, res) => {\n    res.send(books);\n};\n\n// Get a single book by ID\nexports.getBookById = (req, res) => {\n    const book = books.find(b => b.id === parseInt(req.params.id));\n    if (!book) {\n        return res.status(404).send({ error: { message: \"Book not found\", code: 404 } });\n    }\n    res.send(book);\n};\n\n// Add a new book\nexports.addBook = (req, res) => {\n    const newBook = {\n        id: books.length + 1,\n        title: req.body.title,\n        author: req.body.author,\n        publishedDate: req.body.publishedDate,\n        genre: req.body.genre\n    };\n    books.push(newBook);\n    res.status(201).send(newBook);\n};\n\n// Update a book by ID\nexports.updateBook = (req, res) => {\n    const book = books.find(b => b.id === parseInt(req.params.id));\n    if (!book) {\n        return res.status(404).send({ error: { message: \"Book not found\", code: 404 } });\n    }\n    book.title = req.body.title || book.title;\n    book.author = req.body.author || book.author;\n    book.publishedDate = req.body.publishedDate || book.publishedDate;\n    book.genre = req.body.genre || book.genre;\n    res.send(book);\n};\n\n// Delete a book by ID\nexports.deleteBook = (req, res) => {\n    const bookIndex = books.findIndex(b => b.id === parseInt(req.params.id));\n    if (bookIndex === -1) {\n        return res.status(404).send({ error: { message: \"Book not found\", code: 404 } });\n    }\n    books.splice(bookIndex, 1);\n    res.status(204).send();\n};",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"Book Catalog API\",\n        \"version\": \"1.0.0\",\n        \"description\": \"API for managing a catalog of books. It allows users to add, retrieve, update, and delete books.\",\n        \"termsOfService\": \"https://example.com/terms\",\n        \"contact\": {\n            \"name\": \"jake\",\n            \"email\": \"example@domain.com\",\n            \"url\": \"https://jake.com\"\n        },\n        \"license\": {\n            \"name\": \"Apache 2.0\",\n            \"url\": \"https://www.apache.org/licenses/LICENSE-2.0\"\n        }\n    },\n    \"servers\": [\n        {\n            \"url\": \"https://book-catalog-api.vercel.app\",\n            \"description\": \"Production server\"\n        },\n        {\n            \"url\": \"https://localhost:3000\",\n            \"description\": \"Development server\"\n        }\n    ],\n    \"paths\": {\n        \"/v1/books\": {\n            \"get\": {\n                \"summary\": \"Get all books\",\n                \"description\": \"Retrieve all books in the catalog. This endpoint returns a list of all books, useful for displaying or processing all available books.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"A list of all books was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Book\"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the books.\"\n                    }\n                }\n            }\n        },\n        \"/v1/book/{id}\": {\n            \"get\": {\n                \"summary\": \"Get a book by ID\",\n                \"description\": \"Retrieve a single book by its ID. This endpoint returns the details of the specified book, useful for viewing or editing the book's information.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"description\": \"The ID of the book to retrieve.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\",\n                            \"example\": 1\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The book was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Book\"\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"No book was found with the specified ID.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                },\n                                \"examples\": {\n                                    \"notFound\": {\n                                        \"summary\": \"Book not found\",\n                                        \"value\": {\n                                            \"error\": {\n                                                \"message\": \"Book not found\",\n                                                \"code\": 404\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the book.\"\n                    }\n                }\n            },\n            \"put\": {\n                \"summary\": \"Update a book by ID\",\n                \"description\": \"Update the details of a book by its ID. This endpoint allows for modifications to an existing book's information, including its title, author, publication date, and genre.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"description\": \"The ID of the book to update.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\",\n                            \"example\": 1\n                        }\n                    }\n                ],\n                \"requestBody\": {\n                    \"description\": \"The updated details of the book.\",\n                    \"required\": true,\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/Book\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The book was successfully updated.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Book\"\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"No book was found with the specified ID.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                },\n                                \"examples\": {\n                                    \"notFound\": {\n                                        \"summary\": \"Book not found\",\n                                        \"value\": {\n                                            \"error\": {\n                                                \"message\": \"Book not found\",\n                                                \"code\": 404\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to update the book.\"\n                    }\n                }\n            },\n            \"delete\": {\n                \"summary\": \"Delete a book by ID\",\n                \"description\": \"Remove a book from the catalog by its ID. This endpoint allows for the deletion of a book, freeing up its ID for future use.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"description\": \"The ID of the book to delete.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\",\n                            \"example\": 1\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"204\": {\n                        \"description\": \"The book was successfully deleted.\"\n                    },\n                    \"404\": {\n                        \"description\": \"No book was found with the specified ID.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                },\n                                \"examples\": {\n                                    \"notFound\": {\n                                        \"summary\": \"Book not found\",\n                                        \"value\": {\n                                            \"error\": {\n                                                \"message\": \"Book not found\",\n                                                \"code\": 404\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to delete the book.\"\n                    }\n                }\n            }\n        },\n        \"/v1/book\": {\n            \"post\": {\n                \"summary\": \"Add a new book\",\n                \"description\": \"Add a new book to the catalog. This endpoint allows users to create a new entry for a book with details such as title, author, publication date, and genre.\",\n                \"requestBody\": {\n                    \"description\": \"The details of the new book.\",\n                    \"required\": true,\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/Book\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"201\": {\n                        \"description\": \"The book was successfully added to the catalog.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Book\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to add the book.\"\n                    }\n                }\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"Book\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"id\": {\n                        \"type\": \"integer\",\n                        \"description\": \"The unique ID of the book.\",\n                        \"example\": 1\n                    },\n                    \"title\": {\n                        \"type\": \"string\",\n                        \"description\": \"The title of the book.\",\n                        \"example\": \"The Great Gatsby\"\n                    },\n                    \"author\": {\n                        \"type\": \"string\",\n                        \"description\": \"The author of the book.\",\n                        \"example\": \"F. Scott Fitzgerald\"\n                    },\n                    \"publishedDate\": {\n                        \"type\": \"string\",\n                        \"format\": \"date\",\n                        \"description\": \"The publication date of the book.\",\n                        \"example\": \"1925-04-10\"\n                    },\n                    \"genre\": {\n                        \"type\": \"string\",\n                        \"description\": \"The genre of the book.\",\n                        \"example\": \"Classic\"\n                    }\n                }\n            },\n            \"Error\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"error\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"message\": {\n                                \"type\": \"string\",\n                                \"description\": \"A message describing the error.\",\n                                \"example\": \"Book not found\"\n                            },\n                            \"code\": {\n                                \"type\": \"integer\",\n                                \"description\": \"The error code associated with this message.\",\n                                \"example\": 404\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n} [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nconst express = require('express');\nconst router = express.Router();\nconst noteController = require('../controllers/note_controller');\n\n// Get all notes\nrouter.get(\"/v1/notes\", noteController.getAllNotes);\n\n// Get a single note by ID\nrouter.get(\"/v1/note/:id\", noteController.getNoteById);\n\n// Add a new note\nrouter.post(\"/v1/note\", noteController.addNote);\n\n// Update a note by ID\nrouter.put(\"/v1/note/:id\", noteController.updateNote);\n\n// Delete a note by ID\nrouter.delete(\"/v1/note/:id\", noteController.deleteNote);\n\nmodule.exports = router;\n\n\nBelow are the implementations:\n\nconst notes = require(\"../notes\");\n\n// Get all notes\nexports.getAllNotes = (req, res) => {\n    res.send(notes);\n};\n\n// Get a single note by ID\nexports.getNoteById = (req, res) => {\n    const note = notes.find(n => n.id === parseInt(req.params.id));\n    if (!note) {\n        return res.status(404).send({ error: { message: \"Note not found\", code: 404 } });\n    }\n    res.send(note);\n};\n\n// Add a new note\nexports.addNote = (req, res) => {\n    const newNote = {\n        id: notes.length + 1,\n        title: req.body.title,\n        content: req.body.content,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n    notes.push(newNote);\n    res.status(201).send(newNote);\n};\n\n// Update a note by ID\nexports.updateNote = (req, res) => {\n    const note = notes.find(n => n.id === parseInt(req.params.id));\n    if (!note) {\n        return res.status(404).send({ error: { message: \"Note not found\", code: 404 } });\n    }\n    note.title = req.body.title || note.title;\n    note.content = req.body.content || note.content;\n    note.updatedAt = new Date().toISOString();\n    res.send(note);\n};\n\n// Delete a note by ID\nexports.deleteNote = (req, res) => {\n    const noteIndex = notes.findIndex(n => n.id === parseInt(req.params.id));\n    if (noteIndex === -1) {\n        return res.status(404).send({ error: { message: \"Note not found\", code: 404 } });\n    }\n    notes.splice(noteIndex, 1);\n    res.status(204).send();\n};",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"Note-Taking API\",\n        \"version\": \"1.0.0\",\n        \"description\": \"API for managing personal notes. It allows users to create, retrieve, update, and delete notes.\",\n        \"termsOfService\": \"https://example.com/terms\",\n        \"contact\": {\n            \"name\": \"fotiecodes\",\n            \"email\": \"contact@example.com\",\n            \"url\": \"https://example.com\"\n        },\n        \"license\": {\n            \"name\": \"Apache 2.0\",\n            \"url\": \"https://www.apache.org/licenses/LICENSE-2.0\"\n        }\n    },\n    \"servers\": [\n        {\n            \"url\": \"https://note-taking-api.vercel.app\",\n            \"description\": \"Production server\"\n        },\n        {\n            \"url\": \"https://localhost:3000\",\n            \"description\": \"Development server\"\n        }\n    ],\n    \"paths\": {\n        \"/v1/notes\": {\n            \"get\": {\n                \"summary\": \"Get all notes\",\n                \"description\": \"Retrieve all notes. This endpoint returns a list of all notes, useful for displaying or processing all available notes.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"A list of all notes was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Note\"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the notes.\"\n                    }\n                }\n            }\n        },\n        \"/v1/note/{id}\": {\n            \"get\": {\n                \"summary\": \"Get a note by ID\",\n                \"description\": \"Retrieve a single note by its ID. This endpoint returns the details of the specified note, useful for viewing or editing the note's information.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"description\": \"The ID of the note to retrieve.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\",\n                            \"example\": 1\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The note was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Note\"\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"No note was found with the specified ID.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                },\n                                \"examples\": {\n                                    \"notFound\": {\n                                        \"summary\": \"Note not found\",\n                                        \"value\": {\n                                            \"error\": {\n                                                \"message\": \"Note not found\",\n                                                \"code\": 404\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the note.\"\n                    }\n                }\n            },\n            \"put\": {\n                \"summary\": \"Update a note by ID\",\n                \"description\": \"Update the details of a note by its ID. This endpoint allows for modifications to an existing note's information, including its title and content.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"description\": \"The ID of the note to update.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\",\n                            \"example\": 1\n                        }\n                    }\n                ],\n                \"requestBody\": {\n                    \"description\": \"The updated details of the note.\",\n                    \"required\": true,\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/Note\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The note was successfully updated.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Note\"\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"No note was found with the specified ID.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                },\n                                \"examples\": {\n                                    \"notFound\": {\n                                        \"summary\": \"Note not found\",\n                                        \"value\": {\n                                            \"error\": {\n                                                \"message\": \"Note not found\",\n                                                \"code\": 404\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to update the note.\"\n                    }\n                }\n            },\n            \"delete\": {\n                \"summary\": \"Delete a note by ID\",\n                \"description\": \"Remove a note from the catalog by its ID. This endpoint allows for the deletion of a note, freeing up its ID for future use.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"description\": \"The ID of the note to delete.\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\",\n                            \"example\": 1\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"204\": {\n                        \"description\": \"The note was successfully deleted.\"\n                    },\n                    \"404\": {\n                        \"description\": \"No note was found with the specified ID.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                },\n                                \"examples\": {\n                                    \"notFound\": {\n                                        \"summary\": \"Note not found\",\n                                        \"value\": {\n                                            \"error\": {\n                                                \"message\": \"Note not found\",\n                                                \"code\": 404\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to delete the note.\"\n                    }\n                }\n            }\n        },\n        \"/v1/note\": {\n            \"post\": {\n                \"summary\": \"Add a new note\",\n                \"description\": \"Create a new note in the catalog. This endpoint allows users to create a new note with details such as title and content.\",\n                \"requestBody\": {\n                    \"description\": \"The details of the new note.\",\n                    \"required\": true,\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/Note\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"201\": {\n                        \"description\": \"The note was successfully created.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Note\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to create the note.\"\n                    }\n                }\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"Note\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"id\": {\n                        \"type\": \"integer\",\n                        \"description\": \"The unique ID of the note.\",\n                        \"example\": 1\n                    },\n                    \"title\": {\n                        \"type\": \"string\",\n                        \"description\": \"The title of the note.\",\n                        \"example\": \"Meeting Notes\"\n                    },\n                    \"content\": {\n                        \"type\": \"string\",\n                        \"description\": \"The content of the note.\",\n                        \"example\": \"Discussed the new project timeline.\"\n                    },\n                    \"createdAt\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"description\": \"The date and time when the note was created.\",\n                        \"example\": \"2024-08-28T10:00:00Z\"\n                    },\n                    \"updatedAt\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"description\": \"The date and time when the note was last updated.\",\n                        \"example\": \"2024-08-28T10:30:00Z\"\n                    }\n                }\n            },\n            \"Error\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"error\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"message\": {\n                                \"type\": \"string\",\n                                \"description\": \"A message describing the error.\",\n                                \"example\": \"Note not found\"\n                            },\n                            \"code\": {\n                                \"type\": \"integer\",\n                                \"description\": \"The error code associated with this message.\",\n                                \"example\": 404\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n} [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "Below are the defined routes:\n\nconst express = require('express');\nconst router = express.Router();\nconst eventController = require('../controllers/event_controller');\n\n// Get all events\nrouter.get(\"/v1/events\", eventController.getAllEvents);\n\n// Get a single event by ID\nrouter.get(\"/v1/event/:id\", eventController.getEventById);\n\n// Add a new event\nrouter.post(\"/v1/event\", eventController.addEvent);\n\n// Update an event by ID\nrouter.put(\"/v1/event/:id\", eventController.updateEvent);\n\n// Delete an event by ID\nrouter.delete(\"/v1/event/:id\", eventController.deleteEvent);\n\n// Get all venues\nrouter.get(\"/v1/venues\", eventController.getAllVenues);\n\n// Get a single venue by ID\nrouter.get(\"/v1/venue/:id\", eventController.getVenueById);\n\n// Add a new venue\nrouter.post(\"/v1/venue\", eventController.addVenue);\n\n// Update a venue by ID\nrouter.put(\"/v1/venue/:id\", eventController.updateVenue);\n\n// Delete a venue by ID\nrouter.delete(\"/v1/venue/:id\", eventController.deleteVenue);\n\n// Get all attendees for an event\nrouter.get(\"/v1/event/:id/attendees\", eventController.getEventAttendees);\n\n// Add an attendee to an event\nrouter.post(\"/v1/event/:id/attendee\", eventController.addAttendeeToEvent);\n\n// Remove an attendee from an event\nrouter.delete(\"/v1/event/:id/attendee/:attendeeId\", eventController.removeAttendeeFromEvent);\n\nmodule.exports = router;\n\n\nBelow are the implementations:\n\nconst events = require(\"../events\");\nconst venues = require(\"../venues\");\nconst attendees = require(\"../attendees\");\n\n// Get all events\nexports.getAllEvents = (req, res) => {\n    res.send(events);\n};\n\n// Get a single event by ID\nexports.getEventById = (req, res) => {\n    const event = events.find(e => e.id === parseInt(req.params.id));\n    if (!event) {\n        return res.status(404).send({ error: { message: \"Event not found\", code: 404 } });\n    }\n    res.send(event);\n};\n\n// Add a new event\nexports.addEvent = (req, res) => {\n    const newEvent = {\n        id: events.length + 1,\n        name: req.body.name,\n        date: req.body.date,\n        venueId: req.body.venueId,\n        attendees: [],\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n    events.push(newEvent);\n    res.status(201).send(newEvent);\n};\n\n// Update an event by ID\nexports.updateEvent = (req, res) => {\n    const event = events.find(e => e.id === parseInt(req.params.id));\n    if (!event) {\n        return res.status(404).send({ error: { message: \"Event not found\", code: 404 } });\n    }\n    event.name = req.body.name || event.name;\n    event.date = req.body.date || event.date;\n    event.venueId = req.body.venueId || event.venueId;\n    event.updatedAt = new Date().toISOString();\n    res.send(event);\n};\n\n// Delete an event by ID\nexports.deleteEvent = (req, res) => {\n    const eventIndex = events.findIndex(e => e.id === parseInt(req.params.id));\n    if (eventIndex === -1) {\n        return res.status(404).send({ error: { message: \"Event not found\", code: 404 } });\n    }\n    events.splice(eventIndex, 1);\n    res.status(204).send();\n};\n\n// Get all venues\nexports.getAllVenues = (req, res) => {\n    res.send(venues);\n};\n\n// Get a single venue by ID\nexports.getVenueById = (req, res) => {\n    const venue = venues.find(v => v.id === parseInt(req.params.id));\n    if (!venue) {\n        return res.status(404).send({ error: { message: \"Venue not found\", code: 404 } });\n    }\n    res.send(venue);\n};\n\n// Add a new venue\nexports.addVenue = (req, res) => {\n    const newVenue = {\n        id: venues.length + 1,\n        name: req.body.name,\n        location: req.body.location,\n        capacity: req.body.capacity,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n    venues.push(newVenue);\n    res.status(201).send(newVenue);\n};\n\n// Update a venue by ID\nexports.updateVenue = (req, res) => {\n    const venue = venues.find(v => v.id === parseInt(req.params.id));\n    if (!venue) {\n        return res.status(404).send({ error: { message: \"Venue not found\", code: 404 } });\n    }\n    venue.name = req.body.name || venue.name;\n    venue.location = req.body.location || venue.location;\n    venue.capacity = req.body.capacity || venue.capacity;\n    venue.updatedAt = new Date().toISOString();\n    res.send(venue);\n};\n\n// Delete a venue by ID\nexports.deleteVenue = (req, res) => {\n    const venueIndex = venues.findIndex(v => v.id === parseInt(req.params.id));\n    if (venueIndex === -1) {\n        return res.status(404).send({ error: { message: \"Venue not found\", code: 404 } });\n    }\n    venues.splice(venueIndex, 1);\n    res.status(204).send();\n};\n\n// Get all attendees for an event\nexports.getEventAttendees = (req, res) => {\n    const event = events.find(e => e.id === parseInt(req.params.id));\n    if (!event) {\n        return res.status(404).send({ error: { message: \"Event not found\", code: 404 } });\n    }\n    const eventAttendees = attendees.filter(a => event.attendees.includes(a.id));\n    res.send(eventAttendees);\n};\n\n// Add an attendee to an event\nexports.addAttendeeToEvent = (req, res) => {\n    const event = events.find(e => e.id === parseInt(req.params.id));\n    if (!event) {\n        return res.status(404).send({ error: { message: \"Event not found\", code: 404 } });\n    }\n    const attendee = {\n        id: attendees.length + 1,\n        name: req.body.name,\n        email: req.body.email\n    };\n    attendees.push(attendee);\n    event.attendees.push(attendee.id);\n    event.updatedAt = new Date().toISOString();\n    res.status(201).send(attendee);\n};\n\n// Remove an attendee from an event\nexports.removeAttendeeFromEvent = (req, res) => {\n    const event = events.find(e => e.id === parseInt(req.params.id));\n    if (!event) {\n        return res.status(404).send({ error: { message: \"Event not found\", code: 404 } });\n    }\n    const attendeeIndex = event.attendees.indexOf(parseInt(req.params.attendeeId));\n    if (attendeeIndex === -1) {\n        return res.status(404).send({ error: { message: \"Attendee not found\", code: 404 } });\n    }\n    event.attendees.splice(attendeeIndex, 1);\n    event.updatedAt = new Date().toISOString();\n    res.status(204).send();\n};",
    "answer": "[SPEC] {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"Event Management API\",\n        \"version\": \"1.0.0\",\n        \"description\": \"API for managing events, venues, and attendees. Allows for creating, updating, and managing events, venues, and attendees.\",\n        \"termsOfService\": \"https://example.com/terms\",\n        \"contact\": {\n            \"name\": \"fotiecodes\",\n            \"email\": \"contact@fotiecodes.com\",\n            \"url\": \"https://fotiecodes.com\"\n        },\n        \"license\": {\n            \"name\": \"Apache 2.0\",\n            \"url\": \"https://www.apache.org/licenses/LICENSE-2.0\"\n        }\n    },\n    \"servers\": [\n        {\n            \"url\": \"https://event-management-api.vercel.app\",\n            \"description\": \"Production server\"\n        },\n        {\n            \"url\": \"https://localhost:3000\",\n            \"description\": \"Development server\"\n        }\n    ],\n    \"paths\": {\n        \"/v1/events\": {\n            \"get\": {\n                \"summary\": \"Get all events\",\n                \"description\": \"Retrieve all events. This endpoint returns a list of all events.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"A list of all events was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Event\"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the events.\"\n                    }\n                }\n            }\n        },\n        \"/v1/events/new\": {\n        \"post\": {\n            \"summary\": \"Add a new event\",\n            \"description\": \"Create a new event with the specified details.\",\n            \"requestBody\": {\n                \"required\": true,\n                \"content\": {\n                    \"application/json\": {\n                        \"schema\": {\n                            \"$ref\": \"#/components/schemas/Event\"\n                        }\n                    }\n                }\n            },\n            \"responses\": {\n                \"201\": {\n                    \"description\": \"The event was successfully created.\",\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/Event\"\n                            }\n                        }\n                    }\n                },\n                \"500\": {\n                    \"description\": \"An internal error occurred while attempting to create the event.\"\n                }\n            }\n            }\n        },\n        \"/v1/event/{id}\": {\n            \"get\": {\n                \"summary\": \"Get a single event by ID\",\n                \"description\": \"Retrieve a single event by its ID. This endpoint returns the details of the specified event.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The event was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Event\"\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Event not found\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the event.\"\n                    }\n                }\n            },\n            \"put\": {\n                \"summary\": \"Update an event by ID\",\n                \"description\": \"Update the details of an existing event by its ID. This endpoint allows for updating event details.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                ],\n                \"requestBody\": {\n                    \"required\": true,\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/Event\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The event was successfully updated.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Event\"\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Event not found\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to update the event.\"\n                    }\n                }\n            },\n            \"delete\": {\n                \"summary\": \"Delete an event by ID\",\n                \"description\": \"Delete an event by its ID. This endpoint removes the event from the system.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"204\": {\n                        \"description\": \"The event was successfully deleted.\"\n                    },\n                    \"404\": {\n                        \"description\": \"Event not found\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to delete the event.\"\n                    }\n                }\n            }\n        },\n        \"/v1/venues\": {\n            \"get\": {\n                \"summary\": \"Get all venues\",\n                \"description\": \"Retrieve all venues. This endpoint returns a list of all venues.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"A list of all venues was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Venue\"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the venues.\"\n                    }\n                }\n            }\n        },\n        \"/v1/venues/new\": {\n            \"post\": {\n                \"summary\": \"Add a new venue\",\n                \"description\": \"Create a new venue with the specified details.\",\n                \"requestBody\": {\n                    \"required\": true,\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/Venue\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"201\": {\n                        \"description\": \"The venue was successfully created.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Venue\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to create the venue.\"\n                    }\n                }\n                }\n            },\n        \"/v1/venue/{id}\": {\n            \"get\": {\n                \"summary\": \"Get a single venue by ID\",\n                \"description\": \"Retrieve a single venue by its ID. This endpoint returns the details of the specified venue.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The venue was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Venue\"\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Venue not found\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the venue.\"\n                    }\n                }\n            },\n            \"put\": {\n                \"summary\": \"Update a venue by ID\",\n                \"description\": \"Update the details of an existing venue by its ID. This endpoint allows for updating venue details.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                ],\n                \"requestBody\": {\n                    \"required\": true,\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/Venue\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"The venue was successfully updated.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Venue\"\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Venue not found\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to update the venue.\"\n                    }\n                }\n            },\n            \"delete\": {\n                \"summary\": \"Delete a venue by ID\",\n                \"description\": \"Delete a venue by its ID. This endpoint removes the venue from the system.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"204\": {\n                        \"description\": \"The venue was successfully deleted.\"\n                    },\n                    \"404\": {\n                        \"description\": \"Venue not found\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to delete the venue.\"\n                    }\n                }\n            }\n        },\n        \"/v1/event/{id}/attendees\": {\n            \"get\": {\n                \"summary\": \"Get all attendees for an event\",\n                \"description\": \"Retrieve all attendees for a specified event.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"A list of attendees for the event was successfully retrieved.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"$ref\": \"#/components/schemas/Attendee\"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Event not found\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to retrieve the attendees.\"\n                    }\n                }\n            }\n        },\n        \"/v1/event/{id}/attendee\": {\n            \"post\": {\n                \"summary\": \"Add an attendee to an event\",\n                \"description\": \"Add a new attendee to a specified event.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                ],\n                \"requestBody\": {\n                    \"required\": true,\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\n                                \"$ref\": \"#/components/schemas/Attendee\"\n                            }\n                        }\n                    }\n                },\n                \"responses\": {\n                    \"201\": {\n                        \"description\": \"The attendee was successfully added to the event.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Attendee\"\n                                }\n                            }\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Event not found\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to add the attendee.\"\n                    }\n                }\n            }\n        },\n        \"/v1/event/{id}/attendee/{attendeeId}\": {\n            \"delete\": {\n                \"summary\": \"Remove an attendee from an event\",\n                \"description\": \"Remove an attendee from a specified event.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    },\n                    {\n                        \"name\": \"attendeeId\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"204\": {\n                        \"description\": \"The attendee was successfully removed from the event.\"\n                    },\n                    \"404\": {\n                        \"description\": \"Event or attendee not found\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Error\"\n                                }\n                            }\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"An internal error occurred while attempting to remove the attendee.\"\n                    }\n                }\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n      \"Event\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"id\": {\n                        \"type\": \"integer\",\n                        \"example\": 1\n                    },\n                    \"name\": {\n                        \"type\": \"string\",\n                        \"example\": \"Annual Tech Conference\"\n                    },\n                    \"date\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"example\": \"2024-09-30T09:00:00Z\"\n                    },\n                    \"venueId\": {\n                        \"type\": \"integer\",\n                        \"example\": 1\n                    },\n                    \"attendees\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"createdAt\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"example\": \"2024-08-28T12:00:00Z\"\n                    },\n                    \"updatedAt\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"example\": \"2024-08-28T12:00:00Z\"\n                    }\n                },\n                \"required\": [\"name\", \"date\", \"venueId\"]\n            },\n            \"Venue\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"id\": {\n                        \"type\": \"integer\",\n                        \"example\": 1\n                    },\n                    \"name\": {\n                        \"type\": \"string\",\n                        \"example\": \"Grand Hall\"\n                    },\n                    \"location\": {\n                        \"type\": \"string\",\n                        \"example\": \"123 Main St, Cityville, Country\"\n                    },\n                    \"capacity\": {\n                        \"type\": \"integer\",\n                        \"example\": 500\n                    },\n                    \"createdAt\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"example\": \"2024-08-28T12:00:00Z\"\n                    },\n                    \"updatedAt\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"example\": \"2024-08-28T12:00:00Z\"\n                    }\n                },\n                \"required\": [\"name\", \"location\", \"capacity\"]\n            },\n            \"Attendee\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"id\": {\n                        \"type\": \"integer\"\n                    },\n                    \"name\": {\n                        \"type\": \"string\"\n                    },\n                    \"email\": {\n                        \"type\": \"string\",\n                        \"format\": \"email\"\n                    }\n                },\n                \"required\": [\"name\", \"email\"]\n            },\n            \"Error\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"message\": {\n                        \"type\": \"string\"\n                    }\n                }\n            }\n        }\n    }\n} [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "source code",
    "answer": "[SPEC] answer [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "source code",
    "answer": "[SPEC] answer [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "source code",
    "answer": "[SPEC] answer [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "source code",
    "answer": "[SPEC] answer [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "source code",
    "answer": "[SPEC] answer [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "source code",
    "answer": "[SPEC] answer [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "source code",
    "answer": "[SPEC] answer [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "source code",
    "answer": "[SPEC] answer [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "source code",
    "answer": "[SPEC] answer [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "source code",
    "answer": "[SPEC] answer [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "source code",
    "answer": "[SPEC] answer [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "source code",
    "answer": "[SPEC] answer [/SPEC]"
  },
  {
    "question": "From now on, generate a valid JSON file API specification adhering to the OpenAPI 3.0.0 standard by utilizing the provided source code. Ensure comprehensive coverage of all aspects including endpoints, return types, schema, detailed explanations of each endpoint's purpose in a small friendly writing paragraph, potential error codes, and any other relevant information. Use the basic information about the API that will be provided separately to fill in the metadata in the API specification.",
    "context": "source code",
    "answer": "[SPEC] answer [/SPEC]"
  }
]